
==================== FINAL INTERFACE ====================
2017-01-09 22:00:20.072508 UTC

interface Regression-0.1.0.0-8KgimJZiYjs9hASSzNeOg5:Matrix 8001
  interface hash: eb9e9275d0615df98ce4a21b7e7a6cec
  ABI hash: c42aa2be386c7d6004f690dbfc3233fd
  export-list hash: 18be04e505ad8cd1cc23ccff77482d88
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: a4046e0fdab24403354cf30558c1ea1c
  sig of: Nothing
  used TH splices: False
  where
exports:
  Matrix.conhor
  Matrix.conver
  Matrix.deleteColumns
  Matrix.emptyM
  Matrix.filterLinesHor
  Matrix.filterLinesVer
  Matrix.findAMostQuadraticEdgeSize
  Matrix.findEdgeSizes
  Matrix.getAvgColumnsMatrix
  Matrix.getColumn
  Matrix.getElementByInd
  Matrix.getHeight
  Matrix.getRangeColumnsMatrix
  Matrix.getRow
  Matrix.getSize
  Matrix.getWidth
  Matrix.howManyElements
  Matrix.normalize
  Matrix.packM
  Matrix.scaleLines
  Matrix.toASquareMatrix
  Matrix.toHeightMatrix
  Matrix.toList
  Matrix.toRectMatrix
  Matrix.transposeM
  Matrix.unpackM
  Matrix.vector
  Matrix.zipWithLines
  Matrix.zipWithM
  Matrix.Matrix
module dependencies:
package dependencies: base-4.9.0.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Either base-4.9.0.0:Data.Functor.Const
                         base-4.9.0.0:Data.Monoid base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:GHC.Generics base-4.9.0.0:GHC.IO.Exception
                         base-4.9.0.0:GHC.TypeLits
import  -/  base-4.9.0.0:Data.Foldable 8aeb682f6c74f97fcf0ace0d608a43ea
import  -/  base-4.9.0.0:Data.List 49b86831b79b49ce5d4d9416ecba61df
import  -/  base-4.9.0.0:Data.OldList 0058409f994fb13ae0616e3f1e5b4dae
import  -/  base-4.9.0.0:Data.Tuple acb0ed10307ed88df6c81b8589f4de16
import  -/  base-4.9.0.0:GHC.Base 8ed3be81c0707b322f975a84ae1bb816
import  -/  base-4.9.0.0:GHC.Err 3bba35a16538d33d424682ce66876cdd
import  -/  base-4.9.0.0:GHC.Float 469226b1bc53433e95d0167dec5d0312
import  -/  base-4.9.0.0:GHC.List 13d2451194c1c6e53b4f4f07947736dd
import  -/  base-4.9.0.0:GHC.Num 48f506a8f4ecf06285d0a0706594dcc0
import  -/  base-4.9.0.0:GHC.Real 08bf4acb5f2508f89d6fbcd57fe232e9
import  -/  base-4.9.0.0:GHC.Show 952347a6ab730bcb25c0854d8bc6ca51
import  -/  base-4.9.0.0:Prelude b9bddb97799837fe67a8d00939a5b6c3
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
122b8ffa4d0f68b3b4de6923709a1573
  $fEqMatrix :: GHC.Classes.Eq a => GHC.Classes.Eq (Matrix.Matrix a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dEq :: GHC.Classes.Eq a).
                  @ (Matrix.Matrix a)
                  (Matrix.$fEqMatrix_$c== @ a $dEq)
                  (Matrix.$fEqMatrix_$c/= @ a $dEq) -}
122b8ffa4d0f68b3b4de6923709a1573
  $fEqMatrix_$c/= ::
    GHC.Classes.Eq a =>
    Matrix.Matrix a -> Matrix.Matrix a -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (x :: Matrix.Matrix a)
                   (y :: Matrix.Matrix a) ->
                 GHC.Classes.not (Matrix.$fEqMatrix_$c== @ a $dEq x y)) -}
122b8ffa4d0f68b3b4de6923709a1573
  $fEqMatrix_$c== ::
    GHC.Classes.Eq a =>
    Matrix.Matrix a -> Matrix.Matrix a -> GHC.Types.Bool
  {- Arity: 3,
     Strictness: <L,1*U(1*C(C1(U)),A)><S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Classes.Eq a)
                   (w1 :: Matrix.Matrix a)
                   (w2 :: Matrix.Matrix a) ->
                 case w1 of ww { Matrix.Matrix ww1 ->
                 case w2 of ww2 { Matrix.Matrix ww3 ->
                 Matrix.$w$c== @ a w ww1 ww3 } }) -}
b76468f678091bef4e93551efa460561
  $fEqMatrix_go :: [[GHC.Types.Bool]] -> Data.Monoid.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
122b8ffa4d0f68b3b4de6923709a1573
  $fFunctorMatrix :: GHC.Base.Functor Matrix.Matrix
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Matrix.Matrix
                  Matrix.$fFunctorMatrix_$cfmap
                  Matrix.$fFunctorMatrix_$c<$ -}
122b8ffa4d0f68b3b4de6923709a1573
  $fFunctorMatrix_$c<$ :: a -> Matrix.Matrix b -> Matrix.Matrix a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S(S),1*U(1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (eta :: a) (eta1 :: Matrix.Matrix b) ->
                 Matrix.$fFunctorMatrix_$cfmap @ b @ a (\ (ds :: b) -> eta) eta1) -}
122b8ffa4d0f68b3b4de6923709a1573
  $fFunctorMatrix_$cfmap ::
    (a -> b) -> Matrix.Matrix a -> Matrix.Matrix b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S(S),1*U(1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (w :: a -> b) (w1 :: Matrix.Matrix a) ->
                 case w1 of ww { Matrix.Matrix ww1 ->
                 case Matrix.$w$cfmap @ a @ b w ww1 of ww2 { Unit# ww3 ->
                 Matrix.Matrix @ b ww3 } }) -}
122b8ffa4d0f68b3b4de6923709a1573
  $fNumMatrix :: GHC.Num.Num a => GHC.Num.Num (Matrix.Matrix a)
  DFunId
  {- Arity: 1,
     Strictness: <L,U(C(C1(U)),A,C(C1(U)),C(U),C(U),C(U),C(U))>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dNum :: GHC.Num.Num a).
                  @ (Matrix.Matrix a)
                  (Matrix.$fNumMatrix_$c+ @ a $dNum)
                  (Matrix.$fNumMatrix_$c- @ a $dNum)
                  (Matrix.$fNumMatrix_$c* @ a $dNum)
                  (Matrix.$fNumMatrix_$cnegate @ a $dNum)
                  (Matrix.$fNumMatrix_$cabs @ a $dNum)
                  (Matrix.$fNumMatrix_$csignum @ a $dNum)
                  (Matrix.$fNumMatrix_$cfromInteger @ a $dNum) -}
25b0784e72beb9f1ec4b0367782c9eab
  $fNumMatrix1 :: (Matrix.Width, Matrix.Height)
  {- Strictness: x -}
122b8ffa4d0f68b3b4de6923709a1573
  $fNumMatrix_$c* ::
    GHC.Num.Num a =>
    Matrix.Matrix a -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,C(C1(U)),A,A,A,C(U))><S(S),1*U(U)><S(S),1*U(U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Num.Num a)
                   (w1 :: Matrix.Matrix a)
                   (w2 :: Matrix.Matrix a) ->
                 case w1 of ww { Matrix.Matrix ww1 ->
                 case w2 of ww2 { Matrix.Matrix ww3 ->
                 case Matrix.$w$c* @ a w ww1 ww3 of ww4 { Unit# ww5 ->
                 Matrix.Matrix @ a ww5 } } }) -}
122b8ffa4d0f68b3b4de6923709a1573
  $fNumMatrix_$c+ ::
    GHC.Num.Num a =>
    Matrix.Matrix a -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 3,
     Strictness: <L,1*U(1*C(C1(U)),A,A,A,A,A,A)><S(S),1*U(1*U)><S(S),1*U(1*U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dNum :: GHC.Num.Num a)
                   (eta :: Matrix.Matrix a)
                   (eta1 :: Matrix.Matrix a) ->
                 Matrix.zipWithM @ a @ a @ a (GHC.Num.+ @ a $dNum) eta eta1) -}
122b8ffa4d0f68b3b4de6923709a1573
  $fNumMatrix_$c- ::
    GHC.Num.Num a =>
    Matrix.Matrix a -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,C(C1(U)),C(U),C(U),C(U),C(U))><L,U><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ a
                   ($dNum :: GHC.Num.Num a)
                   (x :: Matrix.Matrix a)
                   (y :: Matrix.Matrix a) ->
                 Matrix.$fNumMatrix_$c+
                   @ a
                   $dNum
                   x
                   (Matrix.$fNumMatrix_$cnegate @ a $dNum y)) -}
122b8ffa4d0f68b3b4de6923709a1573
  $fNumMatrix_$cabs ::
    GHC.Num.Num a => Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(A,A,A,A,1*C(U),A,A)><S(S),1*U(1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) (eta :: Matrix.Matrix a) ->
                 Matrix.$fFunctorMatrix_$cfmap
                   @ a
                   @ a
                   (GHC.Num.abs @ a $dNum)
                   eta) -}
122b8ffa4d0f68b3b4de6923709a1573
  $fNumMatrix_$cfromInteger ::
    GHC.Num.Num a => GHC.Integer.Type.Integer -> Matrix.Matrix a
  {- Arity: 2, Strictness: <L,1*U(A,A,A,A,A,A,1*C1(U))><L,U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Num.Num a) (w1 :: GHC.Integer.Type.Integer) ->
                 case Matrix.$w$cfromInteger @ a w w1 of ww { Unit# ww1 ->
                 Matrix.Matrix @ a ww1 }) -}
122b8ffa4d0f68b3b4de6923709a1573
  $fNumMatrix_$cnegate ::
    GHC.Num.Num a => Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(A,A,A,1*C(U),A,A,A)><S(S),1*U(1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) (eta :: Matrix.Matrix a) ->
                 Matrix.$fFunctorMatrix_$cfmap
                   @ a
                   @ a
                   (GHC.Num.negate @ a $dNum)
                   eta) -}
122b8ffa4d0f68b3b4de6923709a1573
  $fNumMatrix_$csignum ::
    GHC.Num.Num a => Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(A,A,A,A,A,1*C(U),A)><S(S),1*U(1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) (eta :: Matrix.Matrix a) ->
                 Matrix.$fFunctorMatrix_$cfmap
                   @ a
                   @ a
                   (GHC.Num.signum @ a $dNum)
                   eta) -}
122b8ffa4d0f68b3b4de6923709a1573
  $fShowMatrix :: GHC.Show.Show a => GHC.Show.Show (Matrix.Matrix a)
  DFunId
  {- Arity: 1, Strictness: <L,U(A,U,A)>m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dShow :: GHC.Show.Show a).
                  @ (Matrix.Matrix a)
                  (Matrix.$fShowMatrix_$cshowsPrec @ a $dShow)
                  (Matrix.$fShowMatrix_$cshow @ a $dShow)
                  (Matrix.$fShowMatrix_$cshowList @ a $dShow) -}
f74a7978e172ed367ea60367f7caf832
  $fShowMatrix1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# " "#) -}
21b8ea3c07c3a706db64d333f562451f
  $fShowMatrix2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "\n"#) -}
c7863848e9ca85f393e8711042ff3e46
  $fShowMatrix3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Empty matrix."#) -}
122b8ffa4d0f68b3b4de6923709a1573
  $fShowMatrix_$cshow ::
    GHC.Show.Show a => Matrix.Matrix a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(A,1*U,A)><S(S),1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Show.Show a) (w1 :: Matrix.Matrix a) ->
                 case w1 of ww { Matrix.Matrix ww1 ->
                 Matrix.$w$cshow @ a w ww1 }) -}
122b8ffa4d0f68b3b4de6923709a1573
  $fShowMatrix_$cshowList ::
    GHC.Show.Show a => [Matrix.Matrix a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(A,U,A)><S,1*U><L,U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [Matrix.Matrix a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Matrix.Matrix a)
                   (\ (x :: Matrix.Matrix a) (s1 :: GHC.Base.String)[OneShot] ->
                    case x of ww { Matrix.Matrix ww1 ->
                    GHC.Base.++ @ GHC.Types.Char (Matrix.$w$cshow @ a $dShow ww1) s1 })
                   ls
                   s) -}
122b8ffa4d0f68b3b4de6923709a1573
  $fShowMatrix_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> Matrix.Matrix a -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <L,1*U(A,1*U,A)><L,A><S(S),1*U(U)><L,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ds :: GHC.Types.Int)
                   (x :: Matrix.Matrix a)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Matrix.$fShowMatrix_$cshow @ a $dShow x))
                   s) -}
262f7aedef7adc80533d57a570c6200e
  $fShowMatrix_z :: [GHC.Types.Char]
  {- Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   Matrix.$fShowMatrix2
                   (GHC.Types.[] @ GHC.Types.Char)) -}
35ba58b718ce06ac8b5f8820d2db9a2d
  $tc'Matrix :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1581162556738802608##
                   5232716248647274342##
                   Matrix.$trModule
                   Matrix.$tc'Matrix1) -}
bfb64adbf64154a41972df4bb4819e4f
  $tc'Matrix1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Matrix"#) -}
f70b53c60539b56dba1c5a8758daa20f
  $tcMatrix :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10858222661871690055##
                   470567836980437485##
                   Matrix.$trModule
                   Matrix.$trModule1) -}
50132c7ab29b2ad40f43e2b40ce3f415
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Matrix.$trModule2
                   Matrix.$trModule1) -}
4fee981e9da8214183bb297fa43d0608
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Matrix"#) -}
1d31216be62825a18fde00671d05e044
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "Regression-0.1.0.0-8KgimJZiYjs9hASSzNeOg5"#) -}
122b8ffa4d0f68b3b4de6923709a1573
  $w$c* :: GHC.Num.Num a => [[a]] -> [[a]] -> (# [[a]] #)
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,C(C1(U)),A,A,A,C(U))><S,U><S,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Num.Num a)
                   (ww :: [[a]])
                   (ww1 :: [[a]]) ->
                 case ww of wild {
                   [] -> case Matrix.$fNumMatrix1 ret_ty (# [[a]] #) of {}
                   : x xs
                   -> case GHC.List.$wlenAcc @ a x 0# of ww2 { DEFAULT ->
                      case ww1 of wild1 {
                        [] -> case Matrix.$fNumMatrix1 ret_ty (# [[a]] #) of {}
                        : x1 xs1
                        -> case GHC.List.$wlenAcc @ [a] wild1 0# of ww3 { DEFAULT ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.==# ww2 ww3) of wild2 {
                             GHC.Types.False
                             -> case Matrix.$wlvl @ a wild wild1 ret_ty (# [[a]] #) of {}
                             GHC.Types.True
                             -> case Matrix.$wtransposeM @ a wild of ww4 { Unit# ww5 ->
                                case Matrix.$wmulling @ a w ww5 wild1 of ww6 { Matrix.Matrix ww7 ->
                                Matrix.$wtransposeM @ a ww7 } } } } } } }) -}
61ecf6dedebefaa64929e6488b15c1e4
  $w$c== :: GHC.Classes.Eq a => [[a]] -> [[a]] -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,1*U(1*C(C1(U)),A)><S,1*U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Classes.Eq a)
                   (ww :: [[a]])
                   (ww1 :: [[a]]) ->
                 case Matrix.$wzipWithM
                        @ a
                        @ a
                        @ GHC.Types.Bool
                        (GHC.Classes.== @ a w)
                        ww
                        ww1 of ww2 { Unit# ww3 ->
                 (Matrix.$fEqMatrix_go ww3) `cast` (Data.Monoid.N:All[0]) }) -}
ed6f5035e5996484162cd0366a029a18
  $w$cfmap :: (a -> b) -> [[a]] -> (# [[b]] #)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Inline: [0] -}
5cec557fd2ad8548b60071a09d6b7227
  $w$cfromInteger ::
    GHC.Num.Num a => GHC.Integer.Type.Integer -> (# [[a]] #)
  {- Arity: 2, Strictness: <L,1*U(A,A,A,A,A,A,1*C1(U))><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Num.Num a)
                   (w1 :: GHC.Integer.Type.Integer) ->
                 let {
                   xs :: a = GHC.Num.fromInteger @ a w w1
                 } in
                 let {
                   xs1 :: [a] = GHC.Types.: @ a xs (GHC.Types.[] @ a)
                 } in
                 Matrix.$wtoRectMatrix
                   @ a
                   (case Matrix.findEdgeSizes @ a xs1 of wild {
                      [] -> case GHC.List.badHead ret_ty Matrix.Width of {}
                      : x ds1 -> case x of wild1 { (,) x1 ds2 -> x1 } })
                   (case Matrix.findEdgeSizes @ a xs1 of wild {
                      [] -> case GHC.List.badHead ret_ty Matrix.Height of {}
                      : x ds1 -> case x of wild1 { (,) ds2 y -> y } })
                   xs1) -}
9ec76b0acda820d9855f45d80f0be8ca
  $w$cshow :: GHC.Show.Show a => [[a]] -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(A,1*U,A)><S,U>, Inline: [0],
     Unfolding: (\ @ a (w :: GHC.Show.Show a) (ww :: [[a]]) ->
                 case ww of wild {
                   [] -> Matrix.$fShowMatrix3
                   : ipv ipv1
                   -> case Matrix.$wtransposeM @ a wild of ww1 { Unit# ww2 ->
                      let {
                        g :: a -> [GHC.Types.Char] = GHC.Show.show @ a w
                      } in
                      letrec {
                        go1 :: [a] -> [GHC.Types.Char] {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds :: [a]) ->
                          case ds of wild1 {
                            [] -> Matrix.$fShowMatrix_z
                            : y ys
                            -> GHC.Base.++
                                 @ GHC.Types.Char
                                 (GHC.Base.++ @ GHC.Types.Char (g y) Matrix.$fShowMatrix1)
                                 (go1 ys) }
                      } in
                      letrec {
                        go2 :: [[a]] -> [GHC.Types.Char]
                          {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds :: [[a]]) ->
                          case ds of wild1 {
                            [] -> GHC.Types.[] @ GHC.Types.Char
                            : y ys -> GHC.Base.++ @ GHC.Types.Char (go1 y) (go2 ys) }
                      } in
                      go2 ww2 } }) -}
4fdde6f6e0cffe076b2af4099c02f593
  $wconcatHorizM :: [[a]] -> [[a]] -> (# [[a]] #)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,U>, Inline: [0] -}
7ea082650e05b364b33714fe94850098
  $wconhor :: [[a]] -> [[a]] -> GHC.Base.Maybe (Matrix.Matrix a)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>, Inline: [0],
     Unfolding: (\ @ a (ww :: [[a]]) (ww1 :: [[a]]) ->
                 case GHC.List.$wlenAcc @ [a] ww 0# of ww2 { DEFAULT ->
                 case GHC.List.$wlenAcc @ [a] ww1 0# of ww3 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# ww2 ww3) of wild {
                   GHC.Types.False -> GHC.Base.Nothing @ (Matrix.Matrix a)
                   GHC.Types.True
                   -> GHC.Base.Just
                        @ (Matrix.Matrix a)
                        (case Matrix.$wconcatHorizM @ a ww ww1 of ww4 { Unit# ww5 ->
                         Matrix.Matrix @ a ww5 }) } } }) -}
48209cd751b98aa773ccb688286d4468
  $wconver :: [[a]] -> [[a]] -> GHC.Base.Maybe (Matrix.Matrix a)
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [0],
     Unfolding: (\ @ a (ww :: [[a]]) (ww1 :: [[a]]) ->
                 case ww of wild {
                   [] -> Matrix.conver1 @ a
                   : x xs
                   -> case ww1 of wild1 {
                        [] -> Matrix.conver1 @ a
                        : y ys
                        -> case GHC.List.$wlenAcc @ a x 0# of ww2 { DEFAULT ->
                           case GHC.List.$wlenAcc @ a y 0# of ww3 { DEFAULT ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.==# ww2 ww3) of wild2 {
                             GHC.Types.False -> GHC.Base.Nothing @ (Matrix.Matrix a)
                             GHC.Types.True
                             -> GHC.Base.Just
                                  @ (Matrix.Matrix a)
                                  (Matrix.Matrix @ a (GHC.Base.++ @ [a] wild wild1)) } } } } }) -}
d9972a5aef61503ba52749a9aeffaf6e
  $wdeleteColumns :: [GHC.Types.Int] -> [[a]] -> (# [[a]] #)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [0] -}
eb929a622dcd123bbe68a817e9f4e7ff
  $wfilterLinesHor :: (a -> GHC.Types.Bool) -> [[a]] -> (# [[a]] #)
  {- Arity: 2, Strictness: <L,C(U)><S,1*U>, Inline: [0],
     Unfolding: (\ @ a (w :: a -> GHC.Types.Bool) (ww :: [[a]]) ->
                 case Matrix.$wtransposeM @ a ww of ww1 { Unit# ww2 ->
                 Matrix.$wtransposeM
                   @ a
                   (GHC.List.filter
                      @ [a]
                      (\ (eta :: [a]) ->
                       letrec {
                         go1 :: [a] -> Data.Monoid.All {- Arity: 1, Strictness: <S,1*U> -}
                         = \ (ds :: [a]) ->
                           case ds of wild {
                             [] -> GHC.Types.True `cast` (Sym (Data.Monoid.N:All[0]))
                             : y ys
                             -> case w y of wild1 {
                                  GHC.Types.False
                                  -> GHC.Types.False `cast` (Sym (Data.Monoid.N:All[0]))
                                  GHC.Types.True -> go1 ys } }
                       } in
                       go1 eta)
                        `cast`
                      (<[a]>_R ->_R Data.Monoid.N:All[0])
                      ww2) }) -}
27223652007f3d7903eab1323dfcd55e
  $wfilterLinesVer ::
    (a -> GHC.Types.Bool) -> Matrix.Matrix a -> (# [[a]] #)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><L,1*U(1*U)>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: a -> GHC.Types.Bool)
                   (w1 :: Matrix.Matrix a) ->
                 (# case w1 of wild { Matrix.Matrix xs ->
                    GHC.List.filter
                      @ [a]
                      (\ (eta :: [a]) ->
                       letrec {
                         go1 :: [a] -> Data.Monoid.All {- Arity: 1, Strictness: <S,1*U> -}
                         = \ (ds :: [a]) ->
                           case ds of wild1 {
                             [] -> GHC.Types.True `cast` (Sym (Data.Monoid.N:All[0]))
                             : y ys
                             -> case w y of wild2 {
                                  GHC.Types.False
                                  -> GHC.Types.False `cast` (Sym (Data.Monoid.N:All[0]))
                                  GHC.Types.True -> go1 ys } }
                       } in
                       go1 eta)
                        `cast`
                      (<[a]>_R ->_R Data.Monoid.N:All[0])
                      xs } #)) -}
f54fdcd78556c525c965bbb60f6b00db
  $wgetAvgRangeAboutColumns ::
    (GHC.Real.Fractional a, GHC.Real.Real a) =>
    [[a]] -> Matrix.Matrix (a, a)
  {- Arity: 3,
     Strictness: <L,U(U,C(C1(U)),A,C(U))><L,U(U,U,C(U))><S,1*U>,
     Inline: [0] -}
ee08e897f76c57bf2bdd1e5c709044fd
  $wgetElementByInd :: GHC.Prim.Int# -> GHC.Prim.Int# -> [[a]] -> a
  {- Arity: 3, Strictness: <S,U><S,U><S,U>, Inline: [0],
     Unfolding: (\ @ a
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: [[a]]) ->
                 case GHC.List.$wlenAcc @ [a] ww2 0# of ww3 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># ww ww3) of wild {
                   GHC.Types.False
                   -> case ww2 of wild1 {
                        [] -> case GHC.List.badHead ret_ty a of {}
                        : x ds1
                        -> case GHC.List.$wlenAcc @ a x 0# of ww4 { DEFAULT ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.># ww1 ww4) of wild2 {
                             GHC.Types.False
                             -> Matrix.getElementByInd3
                                  @ a
                                  ww1
                                  (Matrix.getElementByInd2 @ a ww wild1)
                             GHC.Types.True -> Matrix.getElementByInd1 @ a wild1 ww1 ww } } }
                   GHC.Types.True -> Matrix.getElementByInd1 @ a ww2 ww1 ww } }) -}
d94824ac2ee5d58d90fdb35365827270
  $whowManyElements :: [[a]] -> GHC.Prim.Int#
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ @ a (ww :: [[a]]) ->
                 case ww of wild {
                   [] -> case Matrix.howManyElements1 ret_ty GHC.Prim.Int# of {}
                   : x xs
                   -> case GHC.List.$wlenAcc @ a x 0# of ww2 { DEFAULT ->
                      case GHC.List.$wlenAcc @ [a] xs 0# of ww1 { DEFAULT ->
                      GHC.Prim.*# ww2 (GHC.Prim.+# ww1 1#) } } }) -}
122b8ffa4d0f68b3b4de6923709a1573
  $wlvl :: [[a]] -> [[a]] -> Matrix.Matrix a
  {- Arity: 2, Strictness: <B,1*U><B,1*U>x, Inline: [0] -}
2c6104a2e38d8a0c79a44f231d9a577e
  $wmakeListOfOneElementLists :: [a] -> (# [a], [[a]] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
122b8ffa4d0f68b3b4de6923709a1573
  $wmulling :: GHC.Num.Num a => [[a]] -> [[a]] -> Matrix.Matrix a
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,C(C1(U)),A,A,A,C(U))><S,1*U><L,U>,
     Inline: [0] -}
76ac0a9a93d45e8d6acf597247724d00
  $wnormalize :: [[a]] -> (# [[a]] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ @ a (ww :: [[a]]) ->
                 let {
                   xs :: [a] = Matrix.$wtoList @ a ww
                 } in
                 Matrix.$wtoRectMatrix
                   @ a
                   (Matrix.normalize2 @ a xs)
                   (Matrix.normalize1 @ a xs)
                   xs) -}
4ff88a75b22a1c6cbdecda4a7dbc9636
  $wscaleLines ::
    (GHC.Real.Fractional a, GHC.Real.Real a) =>
    [[a]] -> Matrix.Matrix a
  {- Arity: 3,
     Strictness: <L,U(U,C(C1(U)),A,C(U))><L,U(U,U,C(U))><S,1*U>,
     Inline: [0] -}
6dc4f530728abd493d3239f63323c416
  $wtoHeightMatrix :: Matrix.Height -> [a] -> (# [[a]] #)
  {- Arity: 2, Strictness: <L,U(U)><S,U>, Inline: [0],
     Unfolding: (\ @ a (w :: Matrix.Height) (w1 :: [a]) ->
                 Matrix.$wtoRectMatrix
                   @ a
                   (case GHC.List.$wlenAcc @ a w1 0# of ww2 { DEFAULT ->
                    case w of ww1 { GHC.Types.I# ww3 ->
                    case ww3 of wild {
                      DEFAULT
                      -> case GHC.Prim.quotInt# ww2 wild of ww4 { DEFAULT ->
                         GHC.Types.I# ww4 }
                      -1#
                      -> case ww2 of wild1 {
                           DEFAULT -> GHC.Types.I# (GHC.Prim.quotInt# wild1 -1#)
                           -9223372036854775808#
                           -> case GHC.Real.overflowError ret_ty Matrix.Width of {} }
                      0# -> case GHC.Real.divZeroError ret_ty Matrix.Width of {} } } })
                   w
                   w1) -}
cadf16cb8cbac82cbc478d2a463daa69
  $wtoList :: [[a]] -> [a]
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
49c6d5e415f766f6b5f04d59e7ee94f1
  $wtoRectMatrix ::
    Matrix.Width -> Matrix.Height -> [a] -> (# [[a]] #)
  {- Arity: 3, Strictness: <L,1*U(1*U)><L,U(U)><S,1*U>,
     Inline: [0] -}
489b3f682fbbc6089b62ec2494267e5c
  $wtransposeM :: [[a]] -> (# [[a]] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
64dacbfe3d78f1947b7ed38ac3e07162
  $wzipWithLines :: (a -> a -> a) -> [[a]] -> (# [[a]] #)
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U>, Inline: [0],
     Unfolding: (\ @ a (w :: a -> a -> a) (ww :: [[a]]) ->
                 case ww of wild {
                   [] -> case Matrix.zipWithLines1 ret_ty (# [[a]] #) of {}
                   : x xs
                   -> letrec {
                        go1 :: [[a]] -> [a] {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds :: [[a]]) ->
                          case ds of wild1 {
                            [] -> x : y ys -> GHC.List.zipWith @ a @ a @ a w y (go1 ys) }
                      } in
                      case go1 xs of wild1 {
                        [] -> (# GHC.Types.[] @ [a] #)
                        : ipv ipv1
                        -> (# GHC.Types.: @ [a] wild1 (GHC.Types.[] @ [a]) #) } }) -}
279ed1837860bf8a6d08bc22204d1e07
  $wzipWithM :: (a -> b -> c) -> [[a]] -> [[b]] -> (# [[c]] #)
  {- Arity: 3, Strictness: <L,C(C1(U))><S,1*U><S,1*U>, Inline: [0] -}
72545fac175a28e5a42b4359e64ee950
  type Axis = GHC.Types.Int
c4913ddad7d5a9819854e68100f0761c
  type Height = GHC.Types.Int
122b8ffa4d0f68b3b4de6923709a1573
  data Matrix a = Matrix [[a]]
d2b1d267619af5b6ba9b849ba36bdc39
  type Width = GHC.Types.Int
f4066c5550506b1f72a7823d121e30e6
  conhor ::
    Matrix.Matrix a
    -> Matrix.Matrix a -> GHC.Base.Maybe (Matrix.Matrix a)
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: Matrix.Matrix a) (w1 :: Matrix.Matrix a) ->
                 case w of ww { Matrix.Matrix ww1 ->
                 case w1 of ww2 { Matrix.Matrix ww3 ->
                 Matrix.$wconhor @ a ww1 ww3 } }) -}
33ad1b0bf7f83efea63d3b42be180835
  conver ::
    Matrix.Matrix a
    -> Matrix.Matrix a -> GHC.Base.Maybe (Matrix.Matrix a)
  {- Arity: 2, Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: Matrix.Matrix a) (w1 :: Matrix.Matrix a) ->
                 case w of ww { Matrix.Matrix ww1 ->
                 case w1 of ww2 { Matrix.Matrix ww3 ->
                 Matrix.$wconver @ a ww1 ww3 } }) -}
68e6cc16910fe4b4a7146db085c23d13
  conver1 :: GHC.Base.Maybe (Matrix.Matrix a)
  {- Strictness: x -}
1c1848d80879e0b1fd5a8ae0e36ff47a
  deleteColumns ::
    [GHC.Types.Int] -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U(U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: [GHC.Types.Int]) (w1 :: Matrix.Matrix a) ->
                 case w1 of ww { Matrix.Matrix ww1 ->
                 case Matrix.$wdeleteColumns @ a w ww1 of ww2 { Unit# ww3 ->
                 Matrix.Matrix @ a ww3 } }) -}
63e0aa4b30b5a51118cbaade3f3cfc2e
  emptyM :: Matrix.Matrix a
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (\ @ a -> Matrix.Matrix @ a (GHC.Types.[] @ [a])) -}
a665b868efcc085c29271e2fe240a40b
  filterLinesHor ::
    (a -> GHC.Types.Bool) -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, Strictness: <L,C(U)><S(S),1*U(1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: a -> GHC.Types.Bool) (w1 :: Matrix.Matrix a) ->
                 case w1 of ww { Matrix.Matrix ww1 ->
                 case Matrix.$wfilterLinesHor @ a w ww1 of ww2 { Unit# ww3 ->
                 Matrix.Matrix @ a ww3 } }) -}
7741a867940be1a28a3e3802834eacd7
  filterLinesVer ::
    (a -> GHC.Types.Bool) -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><L,1*U(1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: a -> GHC.Types.Bool) (w1 :: Matrix.Matrix a) ->
                 case Matrix.$wfilterLinesVer @ a w w1 of ww { Unit# ww1 ->
                 Matrix.Matrix @ a ww1 }) -}
e7ea5d34d6346d12315e87c134486a3a
  findAMostQuadraticEdgeSize :: [a] -> (Matrix.Width, Matrix.Height)
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (xs :: [a]) ->
                 case Matrix.findEdgeSizes @ a xs of wild {
                   [] -> GHC.List.badHead @ (Matrix.Width, Matrix.Height)
                   : x ds1 -> x }) -}
67d4589eed0e737bba736d3e293da7f9
  findEdgeSizes :: [a] -> [(Matrix.Width, Matrix.Height)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ @ a (xs :: [a]) ->
                 case GHC.List.$wlenAcc @ a xs 0# of ww2 { DEFAULT ->
                 let {
                   x :: GHC.Prim.Double#
                   = GHC.Prim.sqrtDouble# (GHC.Prim.int2Double# ww2)
                 } in
                 let {
                   n :: GHC.Prim.Int# = GHC.Prim.double2Int# x
                 } in
                 let {
                   $j :: GHC.Prim.Int# -> [(Matrix.Width, Matrix.Height)]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x1 :: GHC.Prim.Int#)[OneShot] ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.># x1 ww2) of wild {
                       GHC.Types.False
                       -> let {
                            lvl50 :: [GHC.Types.Int] = GHC.Enum.eftInt 1# ww2
                          } in
                          letrec {
                            go1 :: GHC.Prim.Int# -> [(Matrix.Width, Matrix.Height)]
                              {- Arity: 1, Strictness: <S,U> -}
                            = \ (x2 :: GHC.Prim.Int#) ->
                              let {
                                z :: [(Matrix.Width, Matrix.Height)]
                                = case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.==# x2 ww2) of wild1 {
                                    GHC.Types.False -> go1 (GHC.Prim.+# x2 1#)
                                    GHC.Types.True -> GHC.Types.[] @ (Matrix.Width, Matrix.Height) }
                              } in
                              let {
                                lvl51 :: GHC.Types.Int = GHC.Types.I# x2
                              } in
                              letrec {
                                go2 :: [GHC.Types.Int] -> [(Matrix.Width, Matrix.Height)]
                                  {- Arity: 1, Strictness: <S,1*U> -}
                                = \ (ds :: [GHC.Types.Int]) ->
                                  case ds of wild1 {
                                    [] -> z
                                    : y ys
                                    -> case y of wild2 { GHC.Types.I# y1 ->
                                       case GHC.Prim.tagToEnum#
                                              @ GHC.Types.Bool
                                              (GHC.Prim.==# (GHC.Prim.*# x2 y1) ww2) of wild3 {
                                         GHC.Types.False -> go2 ys
                                         GHC.Types.True
                                         -> GHC.Types.:
                                              @ (Matrix.Width, Matrix.Height)
                                              (lvl51, wild2)
                                              (go2 ys) } } }
                              } in
                              go2 lvl50
                          } in
                          go1 x1
                       GHC.Types.True -> GHC.Types.[] @ (Matrix.Width, Matrix.Height) }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<## x (GHC.Prim.int2Double# n)) of wild1 {
                   GHC.Types.False -> $j n
                   GHC.Types.True -> $j (GHC.Prim.-# n 1#) } }) -}
7331767a3b5a0dcc4a1f3c95f0a52e59
  getAvgColumnsMatrix ::
    (GHC.Num.Num a, GHC.Real.Fractional a, GHC.Real.Real a) =>
    Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 4,
     Strictness: <L,A><L,U(U,C(C1(U)),A,C(U))><L,U(U,U,C(U))><S(S),1*U(1*U)>m,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   ($dNum :: GHC.Num.Num a)
                   ($dFractional :: GHC.Real.Fractional a)
                   ($dReal :: GHC.Real.Real a)
                   (eta :: Matrix.Matrix a) ->
                 Matrix.$fFunctorMatrix_$cfmap
                   @ (a, a)
                   @ a
                   (Data.Tuple.fst @ a @ a)
                   (Matrix.getAvgRangeAboutColumns
                      @ a
                      (GHC.Real.$p1Fractional @ a $dFractional)
                      $dFractional
                      $dReal
                      eta)) -}
d477151f6622c8c92afcb6f211de1058
  getAvgRangeAboutColumns ::
    (GHC.Num.Num a, GHC.Real.Fractional a, GHC.Real.Real a) =>
    Matrix.Matrix a -> Matrix.Matrix (a, a)
  {- Arity: 4,
     Strictness: <L,A><L,U(U,C(C1(U)),A,C(U))><L,U(U,U,C(U))><S(S),1*U(1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (w :: GHC.Num.Num a)
                   (w1 :: GHC.Real.Fractional a)
                   (w2 :: GHC.Real.Real a)
                   (w3 :: Matrix.Matrix a) ->
                 case w3 of ww { Matrix.Matrix ww1 ->
                 Matrix.$wgetAvgRangeAboutColumns @ a w1 w2 ww1 }) -}
17058f9606217654ac5214e0c7a5d14b
  getColumn :: GHC.Types.Int -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*U)><S,1*U(1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a (n :: GHC.Types.Int) (ds :: Matrix.Matrix a) ->
                 case ds of wild { Matrix.Matrix xs ->
                 Matrix.Matrix
                   @ a
                   (GHC.Types.:
                      @ [a]
                      (Matrix.getColumn1 @ a n xs)
                      (GHC.Types.[] @ [a])) }) -}
225324f3bfd7ece151da76b1a043ebe5
  getColumn1 :: GHC.Types.Int -> [[a]] -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*U)><S,1*U> -}
124bc7bf07a87bf07f3ecd5c2a47ac5e
  getElementByInd ::
    (Matrix.Width, Matrix.Height) -> Matrix.Matrix a -> a
  {- Arity: 2,
     Strictness: <S(S(S)S(S)),1*U(1*U(U),U(U))><S(S),1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: (Matrix.Width, Matrix.Height))
                   (w1 :: Matrix.Matrix a) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case ww2 of ww5 { GHC.Types.I# ww6 ->
                 case w1 of ww7 { Matrix.Matrix ww8 ->
                 Matrix.$wgetElementByInd @ a ww4 ww6 ww8 } } } }) -}
ec1a1ee9a9ee898dbac94340a29eb964
  getElementByInd1 :: [[a]] -> GHC.Prim.Int# -> GHC.Prim.Int# -> a
  {- Arity: 3, Strictness: <L,U><L,U><L,U>x -}
0720a43ee697cdf2ea385cbc8be4b23c
  getElementByInd2 :: GHC.Prim.Int# -> [[a]] -> [a]
  {- Arity: 2, Strictness: <S,U><S,1*U>, Inline: [0] -}
384b4d47cc76c6dc4123e63c1b3c46c4
  getElementByInd3 :: GHC.Prim.Int# -> [a] -> a
  {- Arity: 2, Strictness: <S,U><S,1*U>, Inline: [0] -}
4647ff78d6408515cb642ab2ad5c6315
  getHeight :: Matrix.Matrix a -> Matrix.Height
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (x :: Matrix.Matrix a) ->
                 case x of wild { Matrix.Matrix ds ->
                 case ds of wild1 {
                   [] -> case Matrix.$fNumMatrix1 ret_ty Matrix.Height of {}
                   : x1 xs
                   -> case GHC.List.$wlenAcc @ a x1 0# of ww2 { DEFAULT ->
                      GHC.Types.I# ww2 } } }) -}
8aabcb92c2d1ffd85996f1ad9b7e88a7
  getRangeColumnsMatrix ::
    (GHC.Num.Num a, GHC.Real.Fractional a, GHC.Real.Real a) =>
    Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 4,
     Strictness: <L,A><L,U(U,C(C1(U)),A,C(U))><L,U(U,U,C(U))><S(S),1*U(1*U)>m,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   ($dNum :: GHC.Num.Num a)
                   ($dFractional :: GHC.Real.Fractional a)
                   ($dReal :: GHC.Real.Real a)
                   (eta :: Matrix.Matrix a) ->
                 Matrix.$fFunctorMatrix_$cfmap
                   @ (a, a)
                   @ a
                   (Data.Tuple.snd @ a @ a)
                   (Matrix.getAvgRangeAboutColumns
                      @ a
                      (GHC.Real.$p1Fractional @ a $dFractional)
                      $dFractional
                      $dReal
                      eta)) -}
cd772d3202fd7e328edd84a76c88d0c8
  getRow :: GHC.Types.Int -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, Strictness: <L,1*U(1*U)><S(S),1*U(1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Types.Int) (w1 :: Matrix.Matrix a) ->
                 case w1 of ww { Matrix.Matrix ww1 ->
                 case Matrix.$wtransposeM @ a ww1 of ww2 { Unit# ww3 ->
                 case Matrix.$wtransposeM
                        @ a
                        (GHC.Types.:
                           @ [a]
                           (Matrix.getColumn1 @ a w ww3)
                           (GHC.Types.[] @ [a])) of ww4 { Unit# ww5 ->
                 Matrix.Matrix @ a ww5 } } }) -}
b8f84722c2714e948af155e7af86de90
  getSize :: Matrix.Matrix a -> (Matrix.Width, Matrix.Height)
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Matrix.Matrix a) ->
                 case w of ww { Matrix.Matrix ww1 ->
                 case ww1 of wild {
                   [] -> Matrix.$fNumMatrix1
                   : x xs
                   -> (case GHC.List.$wlenAcc @ [a] wild 0# of ww2 { DEFAULT ->
                       GHC.Types.I# ww2 },
                       case GHC.List.$wlenAcc @ a x 0# of ww2 { DEFAULT ->
                       GHC.Types.I# ww2 }) } }) -}
1e0067f6d2adb6c4396ba2b99f69dfe4
  getWidth :: Matrix.Matrix a -> Matrix.Width
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Matrix.Matrix a) ->
                 case w of ww { Matrix.Matrix ww1 ->
                 case ww1 of wild {
                   [] -> case Matrix.$fNumMatrix1 ret_ty GHC.Types.Int of {}
                   : x xs
                   -> case GHC.List.$wlenAcc
                             @ [a]
                             (GHC.Types.: @ [a] x xs)
                             0# of ww2 { DEFAULT ->
                      GHC.Types.I# ww2 } } }) -}
56ea7e8f60dbc6a64b7c3d8aaf39b00b
  howManyElements :: Matrix.Matrix a -> GHC.Types.Int
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Matrix.Matrix a) ->
                 case w of ww { Matrix.Matrix ww1 ->
                 case Matrix.$whowManyElements @ a ww1 of ww2 { DEFAULT ->
                 GHC.Types.I# ww2 } }) -}
d62547949a3e5907a9e2b97c44a6a3b1
  howManyElements1 :: GHC.Types.Int
  {- Strictness: x -}
454174d5973921ce0bfe5e51ce56927b
  normalize :: Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Matrix.Matrix a) ->
                 case w of ww { Matrix.Matrix ww1 ->
                 case Matrix.$wnormalize @ a ww1 of ww2 { Unit# ww3 ->
                 Matrix.Matrix @ a ww3 } }) -}
6662cd0a29b6f356ea32afcdaef2b1e8
  normalize1 :: [a] -> Matrix.Height
  {- Arity: 1, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (x :: [a]) ->
                 case Matrix.findEdgeSizes @ a x of wild {
                   [] -> case GHC.List.badHead ret_ty Matrix.Height of {}
                   : x1 ds1 -> case x1 of wild1 { (,) ds2 y -> y } }) -}
0c84e3c32c6b0a148239f27a20a13c0d
  normalize2 :: [a] -> Matrix.Width
  {- Arity: 1, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (x :: [a]) ->
                 case Matrix.findEdgeSizes @ a x of wild {
                   [] -> case GHC.List.badHead ret_ty Matrix.Width of {}
                   : x1 ds1 -> case x1 of wild1 { (,) x2 ds2 -> x2 } }) -}
98e95b9920f5ae3930f9227bd6bf05f8
  packM :: [[a]] -> Matrix.Matrix a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m,
     Unfolding: InlineRule (0, True, True) Matrix.Matrix -}
98151d14f2bd9b64a9e40f67327805ea
  scaleLines ::
    (GHC.Num.Num a, GHC.Real.Fractional a, GHC.Real.Real a) =>
    Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 4,
     Strictness: <L,A><L,U(U,C(C1(U)),A,C(U))><L,U(U,U,C(U))><S(S),1*U(1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (w :: GHC.Num.Num a)
                   (w1 :: GHC.Real.Fractional a)
                   (w2 :: GHC.Real.Real a)
                   (w3 :: Matrix.Matrix a) ->
                 case w3 of ww { Matrix.Matrix ww1 ->
                 Matrix.$wscaleLines @ a w1 w2 ww1 }) -}
036931d56c962404c6838a3c38e43590
  toASquareMatrix :: [a] -> Matrix.Matrix a
  {- Arity: 1, Strictness: <S,U>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (xs :: [a]) ->
                 Matrix.toRectMatrix
                   @ a
                   (Matrix.normalize2 @ a xs)
                   (Matrix.normalize1 @ a xs)
                   xs) -}
4da8dab53ac587b4ede3fffa4dd9e26e
  toHeightMatrix :: Matrix.Height -> [a] -> Matrix.Matrix a
  {- Arity: 2, Strictness: <L,U(U)><S,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: Matrix.Height) (w1 :: [a]) ->
                 case Matrix.$wtoHeightMatrix @ a w w1 of ww { Unit# ww1 ->
                 Matrix.Matrix @ a ww1 }) -}
b01ffa36ea5f6d9ffe6d35283688927a
  toList :: Matrix.Matrix a -> [a]
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Matrix.Matrix a) ->
                 case w of ww { Matrix.Matrix ww1 -> Matrix.$wtoList @ a ww1 }) -}
db3ad3007175cd4487cda1de4daacfc3
  toRectMatrix ::
    Matrix.Width -> Matrix.Height -> [a] -> Matrix.Matrix a
  {- Arity: 3, Strictness: <L,1*U(1*U)><L,U(U)><S,1*U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a (w :: Matrix.Width) (w1 :: Matrix.Height) (w2 :: [a]) ->
                 case Matrix.$wtoRectMatrix @ a w w1 w2 of ww { Unit# ww1 ->
                 Matrix.Matrix @ a ww1 }) -}
ea50ce1ca685a9c3904c28c7972b383b
  transposeM :: Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Matrix.Matrix a) ->
                 case w of ww { Matrix.Matrix ww1 ->
                 case Matrix.$wtransposeM @ a ww1 of ww2 { Unit# ww3 ->
                 Matrix.Matrix @ a ww3 } }) -}
7b72f5702e6fc76ef27ea6c8be50d457
  unpackM :: Matrix.Matrix a -> [[a]]
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Matrix.Matrix a) ->
                 case ds of wild { Matrix.Matrix xs -> xs }) -}
1b585a7487ee16680fcb088b53a0ce80
  vector :: [a] -> Matrix.Axis -> Matrix.Matrix a
  {- Arity: 2, Strictness: <S,1*U><L,1*U(1*U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: [a]) (w1 :: Matrix.Axis) ->
                 case w of wild {
                   [] -> Matrix.Matrix @ a (GHC.Types.[] @ [a])
                   : ipv ipv1
                   -> case w1 of wild1 { GHC.Types.I# ds ->
                      case ds of ds1 {
                        DEFAULT -> case Matrix.vector1 ret_ty (Matrix.Matrix a) of {}
                        0#
                        -> Matrix.Matrix @ a (GHC.Types.: @ [a] wild (GHC.Types.[] @ [a]))
                        1#
                        -> Matrix.Matrix
                             @ a
                             (case Matrix.$wmakeListOfOneElementLists
                                     @ a
                                     wild of ww { (#,#) ww1 ww2 ->
                              GHC.Types.: @ [a] ww1 ww2 }) } } }) -}
4ab9d06843065f3575d36305f5830985
  vector1 :: Matrix.Matrix a
  {- Strictness: x -}
33cb3ff3f021473694a13526b4cef2ac
  zipWithLines :: (a -> a -> a) -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, Strictness: <L,C(C1(U))><S(S),1*U(1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: a -> a -> a) (w1 :: Matrix.Matrix a) ->
                 case w1 of ww { Matrix.Matrix ww1 ->
                 case Matrix.$wzipWithLines @ a w ww1 of ww2 { Unit# ww3 ->
                 Matrix.Matrix @ a ww3 } }) -}
5367669813b7c0f823c453582964a1d9
  zipWithLines1 :: Matrix.Matrix a
  {- Strictness: x -}
122b8ffa4d0f68b3b4de6923709a1573
  zipWithM ::
    (a -> b -> c)
    -> Matrix.Matrix a -> Matrix.Matrix b -> Matrix.Matrix c
  {- Arity: 3,
     Strictness: <L,C(C1(U))><S(S),1*U(1*U)><S(S),1*U(1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   @ c
                   (w :: a -> b -> c)
                   (w1 :: Matrix.Matrix a)
                   (w2 :: Matrix.Matrix b) ->
                 case w1 of ww { Matrix.Matrix ww1 ->
                 case w2 of ww2 { Matrix.Matrix ww3 ->
                 case Matrix.$wzipWithM @ a @ b @ c w ww1 ww3 of ww4 { Unit# ww5 ->
                 Matrix.Matrix @ c ww5 } } }) -}
instance [safe] GHC.Classes.Eq [Matrix.Matrix] = Matrix.$fEqMatrix
instance [safe] GHC.Base.Functor [Matrix.Matrix]
  = Matrix.$fFunctorMatrix
instance [safe] GHC.Num.Num [Matrix.Matrix] = Matrix.$fNumMatrix
instance [safe] GHC.Show.Show [Matrix.Matrix] = Matrix.$fShowMatrix
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

