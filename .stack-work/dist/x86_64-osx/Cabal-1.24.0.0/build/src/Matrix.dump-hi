
==================== FINAL INTERFACE ====================
2016-12-30 18:15:28.933832 UTC

interface Regression-0.1.0.0-BgfkxP9qOsG1ta2nZqj6mX:Matrix 8001
  interface hash: 34f10d194831669ca720bcd8ef641f5f
  ABI hash: 7769eaa6888511df16e6097884d7f7f7
  export-list hash: 322b765e82d88335cc249308db1cb917
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: a4046e0fdab24403354cf30558c1ea1c
  sig of: Nothing
  used TH splices: False
  where
exports:
  Matrix.conhor
  Matrix.conver
  Matrix.deleteColumns
  Matrix.emptyM
  Matrix.filterLinesHor
  Matrix.filterLinesVer
  Matrix.findAMostQuadraticEdgeSize
  Matrix.findEdgeSizes
  Matrix.howManyElements
  Matrix.normalize
  Matrix.toASquareMatrix
  Matrix.toHeightMatrix
  Matrix.toList
  Matrix.toRectMatrix
  Matrix.transposeM
  Matrix.vector
  Matrix.zipWithLines
  Matrix.zipWithM
  Matrix.Matrix{Matrix.EmptyM Matrix.Matrix}
module dependencies:
package dependencies: base-4.9.0.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Either base-4.9.0.0:Data.Functor.Const
                         base-4.9.0.0:Data.Monoid base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:GHC.Generics base-4.9.0.0:GHC.IO.Exception
                         base-4.9.0.0:GHC.TypeLits
import  -/  base-4.9.0.0:Data.Foldable 8aeb682f6c74f97fcf0ace0d608a43ea
import  -/  base-4.9.0.0:Data.Tuple acb0ed10307ed88df6c81b8589f4de16
import  -/  base-4.9.0.0:GHC.Base 8ed3be81c0707b322f975a84ae1bb816
import  -/  base-4.9.0.0:GHC.Err 3bba35a16538d33d424682ce66876cdd
import  -/  base-4.9.0.0:GHC.Float 469226b1bc53433e95d0167dec5d0312
import  -/  base-4.9.0.0:GHC.List 13d2451194c1c6e53b4f4f07947736dd
import  -/  base-4.9.0.0:GHC.Num 48f506a8f4ecf06285d0a0706594dcc0
import  -/  base-4.9.0.0:GHC.Real 08bf4acb5f2508f89d6fbcd57fe232e9
import  -/  base-4.9.0.0:GHC.Show 952347a6ab730bcb25c0854d8bc6ca51
import  -/  base-4.9.0.0:Prelude b9bddb97799837fe67a8d00939a5b6c3
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
da4988ece597c0e5952893b053b5093c
  $fEqMatrix :: GHC.Classes.Eq a => GHC.Classes.Eq (Matrix.Matrix a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dEq :: GHC.Classes.Eq a).
                  @ (Matrix.Matrix a)
                  (Matrix.$fEqMatrix_$c== @ a $dEq)
                  (Matrix.$fEqMatrix_$c/= @ a $dEq) -}
b8e3d8f5f50b5f0dcaea3abebc867882
  $fEqMatrix1 :: [[a]]
  {- Strictness: x -}
da4988ece597c0e5952893b053b5093c
  $fEqMatrix_$c/= ::
    GHC.Classes.Eq a =>
    Matrix.Matrix a -> Matrix.Matrix a -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (x :: Matrix.Matrix a)
                   (y :: Matrix.Matrix a) ->
                 GHC.Classes.not (Matrix.$fEqMatrix_$c== @ a $dEq x y)) -}
da4988ece597c0e5952893b053b5093c
  $fEqMatrix_$c== ::
    GHC.Classes.Eq a =>
    Matrix.Matrix a -> Matrix.Matrix a -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,1*U(1*C(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (a1 :: Matrix.Matrix a)
                   (b :: Matrix.Matrix a) ->
                 case Matrix.zipWithM
                        @ a
                        @ a
                        @ GHC.Types.Bool
                        (GHC.Classes.== @ a $dEq)
                        a1
                        b of wild {
                   Matrix.EmptyM
                   -> case Matrix.$fEqMatrix1 ret_ty GHC.Types.Bool of {}
                   Matrix.Matrix xs
                   -> (Matrix.$fEqMatrix_go xs) `cast` (Data.Monoid.N:All[0]) }) -}
f0ae6e44e9003777f28df9bfa17af8db
  $fEqMatrix_go :: [[GHC.Types.Bool]] -> Data.Monoid.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
da4988ece597c0e5952893b053b5093c
  $fFunctorMatrix :: GHC.Base.Functor Matrix.Matrix
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Matrix.Matrix
                  Matrix.$fFunctorMatrix_$cfmap
                  Matrix.$fFunctorMatrix_$c<$ -}
da4988ece597c0e5952893b053b5093c
  $fFunctorMatrix_$c<$ :: a -> Matrix.Matrix b -> Matrix.Matrix a
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (eta :: a) (eta1 :: Matrix.Matrix b) ->
                 Matrix.$fFunctorMatrix_$cfmap @ b @ a (\ (ds :: b) -> eta) eta1) -}
da4988ece597c0e5952893b053b5093c
  $fFunctorMatrix_$cfmap ::
    (a -> b) -> Matrix.Matrix a -> Matrix.Matrix b
  {- Arity: 2, Strictness: <L,C(U)><S,1*U> -}
da4988ece597c0e5952893b053b5093c
  $fNumMatrix :: GHC.Num.Num a => GHC.Num.Num (Matrix.Matrix a)
  DFunId
  {- Arity: 1,
     Strictness: <L,U(C(C1(U)),A,C(C1(U)),C(U),C(U),C(U),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dNum :: GHC.Num.Num a).
                  @ (Matrix.Matrix a)
                  (Matrix.$fNumMatrix_$c+ @ a $dNum)
                  (Matrix.$fNumMatrix_$c- @ a $dNum)
                  (Matrix.$fNumMatrix_$c* @ a $dNum)
                  (Matrix.$fNumMatrix_$cnegate @ a $dNum)
                  (Matrix.$fNumMatrix_$cabs @ a $dNum)
                  (Matrix.$fNumMatrix_$csignum @ a $dNum)
                  (Matrix.$fNumMatrix_$cfromInteger @ a $dNum) -}
da4988ece597c0e5952893b053b5093c
  $fNumMatrix1 :: GHC.Integer.Type.Integer -> Matrix.Matrix a
  {- Strictness: x -}
da4988ece597c0e5952893b053b5093c
  $fNumMatrix_$c* ::
    GHC.Num.Num a =>
    Matrix.Matrix a -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 3,
     Strictness: <L,1*U(A,A,1*C(C1(U)),A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dNum :: GHC.Num.Num a)
                   (eta :: Matrix.Matrix a)
                   (eta1 :: Matrix.Matrix a) ->
                 Matrix.zipWithM @ a @ a @ a (GHC.Num.* @ a $dNum) eta eta1) -}
da4988ece597c0e5952893b053b5093c
  $fNumMatrix_$c+ ::
    GHC.Num.Num a =>
    Matrix.Matrix a -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 3,
     Strictness: <L,1*U(1*C(C1(U)),A,A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dNum :: GHC.Num.Num a)
                   (eta :: Matrix.Matrix a)
                   (eta1 :: Matrix.Matrix a) ->
                 Matrix.zipWithM @ a @ a @ a (GHC.Num.+ @ a $dNum) eta eta1) -}
da4988ece597c0e5952893b053b5093c
  $fNumMatrix_$c- ::
    GHC.Num.Num a =>
    Matrix.Matrix a -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,C(C1(U)),C(U),C(U),C(U),A)><L,U><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ a
                   ($dNum :: GHC.Num.Num a)
                   (x :: Matrix.Matrix a)
                   (y :: Matrix.Matrix a) ->
                 Matrix.$fNumMatrix_$c+
                   @ a
                   $dNum
                   x
                   (Matrix.$fNumMatrix_$cnegate @ a $dNum y)) -}
da4988ece597c0e5952893b053b5093c
  $fNumMatrix_$cabs ::
    GHC.Num.Num a => Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, Strictness: <L,1*U(A,A,A,A,1*C(U),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) (eta :: Matrix.Matrix a) ->
                 Matrix.$fFunctorMatrix_$cfmap
                   @ a
                   @ a
                   (GHC.Num.abs @ a $dNum)
                   eta) -}
da4988ece597c0e5952893b053b5093c
  $fNumMatrix_$cfromInteger ::
    GHC.Num.Num a => GHC.Integer.Type.Integer -> Matrix.Matrix a
  {- Arity: 1, Strictness: <B,A>x,
     Unfolding: InlineRule (1, True, True)
                (\ @ a ($dNum :: GHC.Num.Num a) -> Matrix.$fNumMatrix1 @ a) -}
da4988ece597c0e5952893b053b5093c
  $fNumMatrix_$cnegate ::
    GHC.Num.Num a => Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, Strictness: <L,1*U(A,A,A,1*C(U),A,A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) (eta :: Matrix.Matrix a) ->
                 Matrix.$fFunctorMatrix_$cfmap
                   @ a
                   @ a
                   (GHC.Num.negate @ a $dNum)
                   eta) -}
da4988ece597c0e5952893b053b5093c
  $fNumMatrix_$csignum ::
    GHC.Num.Num a => Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, Strictness: <L,1*U(A,A,A,A,A,1*C(U),A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) (eta :: Matrix.Matrix a) ->
                 Matrix.$fFunctorMatrix_$cfmap
                   @ a
                   @ a
                   (GHC.Num.signum @ a $dNum)
                   eta) -}
da4988ece597c0e5952893b053b5093c
  $fShowMatrix :: GHC.Show.Show a => GHC.Show.Show (Matrix.Matrix a)
  DFunId
  {- Arity: 1, Strictness: <L,U(A,U,A)>m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dShow :: GHC.Show.Show a).
                  @ (Matrix.Matrix a)
                  (Matrix.$fShowMatrix_$cshowsPrec @ a $dShow)
                  (Matrix.$fShowMatrix_$cshow @ a $dShow)
                  (Matrix.$fShowMatrix_$cshowList @ a $dShow) -}
1d38f1d2ac9287b884886386c3029817
  $fShowMatrix1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# " "#) -}
e962fd0fdf806e560106508f2d56ad44
  $fShowMatrix2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "\n"#) -}
694212de63d5b57541a784c97f3efe4d
  $fShowMatrix3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Empty matrix"#) -}
da4988ece597c0e5952893b053b5093c
  $fShowMatrix_$cshow ::
    GHC.Show.Show a => Matrix.Matrix a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(A,1*U,A)><S,1*U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ds :: Matrix.Matrix a) ->
                 case ds of wild {
                   Matrix.EmptyM -> Matrix.$fShowMatrix3
                   Matrix.Matrix ipv
                   -> case Matrix.transposeM @ a wild of wild1 {
                        Matrix.EmptyM
                        -> case Matrix.$fEqMatrix1 ret_ty GHC.Base.String of {}
                        Matrix.Matrix xs
                        -> let {
                             g :: a -> [GHC.Types.Char] = GHC.Show.show @ a $dShow
                           } in
                           letrec {
                             go1 :: [a] -> [GHC.Types.Char] {- Arity: 1, Strictness: <S,1*U> -}
                             = \ (ds1 :: [a]) ->
                               case ds1 of wild2 {
                                 [] -> Matrix.$fShowMatrix_z
                                 : y ys
                                 -> GHC.Base.++
                                      @ GHC.Types.Char
                                      (GHC.Base.++ @ GHC.Types.Char (g y) Matrix.$fShowMatrix1)
                                      (go1 ys) }
                           } in
                           letrec {
                             go2 :: [[a]] -> [GHC.Types.Char]
                               {- Arity: 1, Strictness: <S,1*U> -}
                             = \ (ds1 :: [[a]]) ->
                               case ds1 of wild2 {
                                 [] -> GHC.Types.[] @ GHC.Types.Char
                                 : y ys -> GHC.Base.++ @ GHC.Types.Char (go1 y) (go2 ys) }
                           } in
                           go2 xs } }) -}
da4988ece597c0e5952893b053b5093c
  $fShowMatrix_$cshowList ::
    GHC.Show.Show a => [Matrix.Matrix a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(A,U,A)><S,1*U><L,U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [Matrix.Matrix a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Matrix.Matrix a)
                   (\ (x :: Matrix.Matrix a) (s1 :: GHC.Base.String)[OneShot] ->
                    GHC.Base.++
                      @ GHC.Types.Char
                      (Matrix.$fShowMatrix_$cshow @ a $dShow x)
                      s1)
                   ls
                   s) -}
da4988ece597c0e5952893b053b5093c
  $fShowMatrix_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> Matrix.Matrix a -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <L,1*U(A,1*U,A)><L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ds :: GHC.Types.Int)
                   (x :: Matrix.Matrix a)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Matrix.$fShowMatrix_$cshow @ a $dShow x))
                   s) -}
658be5f7e0538ae3ab408ac70a4f8a7b
  $fShowMatrix_z :: [GHC.Types.Char]
  {- Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   Matrix.$fShowMatrix2
                   (GHC.Types.[] @ GHC.Types.Char)) -}
03e6821fd63fc6ff20ba6b766c45eee6
  $tc'EmptyM :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10998939451333070695##
                   13591662482535266634##
                   Matrix.$trModule
                   Matrix.$tc'EmptyM1) -}
9215a3acadfdde400c2fd6bcc10de73c
  $tc'EmptyM1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'EmptyM"#) -}
6fb38f5e009797391ffa17baadf474f0
  $tc'Matrix :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9519218874261716999##
                   14241207881608406365##
                   Matrix.$trModule
                   Matrix.$tc'Matrix1) -}
1a0fa0ef3920b5f1b72809424f4282eb
  $tc'Matrix1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Matrix"#) -}
2f15a8e14fd2afefe803bfa569cfd167
  $tcMatrix :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6879586085828880067##
                   6167075844438285825##
                   Matrix.$trModule
                   Matrix.$trModule1) -}
90ca189929dc2c55c0b3252a81416dc9
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Matrix.$trModule2
                   Matrix.$trModule1) -}
fc8262e8b372b6e16b1978650674318e
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Matrix"#) -}
2c8fa4d13072e5b49b37cb2650944517
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "Regression-0.1.0.0-BgfkxP9qOsG1ta2nZqj6mX"#) -}
e3b5c6c05547129978ebbe7335a3e3d8
  $wfilterLinesVer ::
    (a -> GHC.Types.Bool) -> Matrix.Matrix a -> (# [[a]] #)
  {- Arity: 2, Strictness: <L,C(U)><L,1*U>, Inline: [0],
     Unfolding: (\ @ a
                   (w :: a -> GHC.Types.Bool)
                   (w1 :: Matrix.Matrix a) ->
                 (# case w1 of wild {
                      Matrix.EmptyM -> case Matrix.$fEqMatrix1 ret_ty [[a]] of {}
                      Matrix.Matrix xs
                      -> GHC.List.filter
                           @ [a]
                           (\ (eta :: [a]) ->
                            letrec {
                              go1 :: [a] -> Data.Monoid.All {- Arity: 1, Strictness: <S,1*U> -}
                              = \ (ds :: [a]) ->
                                case ds of wild1 {
                                  [] -> GHC.Types.True `cast` (Sym (Data.Monoid.N:All[0]))
                                  : y ys
                                  -> case w y of wild2 {
                                       GHC.Types.False
                                       -> GHC.Types.False `cast` (Sym (Data.Monoid.N:All[0]))
                                       GHC.Types.True -> go1 ys } }
                            } in
                            go1 eta)
                             `cast`
                           (<[a]>_R ->_R Data.Monoid.N:All[0])
                           xs } #)) -}
58c63825e11b476b3ce11605602847af
  $whowManyElements :: Matrix.Matrix a -> GHC.Prim.Int#
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ @ a (w :: Matrix.Matrix a) ->
                 case w of wild {
                   Matrix.EmptyM
                   -> case Matrix.howManyElements1 ret_ty GHC.Prim.Int# of {}
                   Matrix.Matrix ds
                   -> case ds of wild1 {
                        [] -> case Matrix.howManyElements1 ret_ty GHC.Prim.Int# of {}
                        : x xs
                        -> case GHC.List.$wlenAcc @ a x 0# of ww2 { DEFAULT ->
                           case GHC.List.$wlenAcc @ [a] xs 0# of ww1 { DEFAULT ->
                           GHC.Prim.*# ww2 (GHC.Prim.+# ww1 1#) } } } }) -}
70c918763baa25c4875f17200f6cbfa8
  $wmakeListOfOneElementLists :: [a] -> (# [a], [[a]] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
595778d6561afb6a26a627b70c56e4ff
  type Axis = GHC.Types.Int
c05c1c6f2d5dc0102a7fe5e405ed8c3f
  type Height = GHC.Types.Int
da4988ece597c0e5952893b053b5093c
  data Matrix a = EmptyM | Matrix [[a]]
0a8afe67efab4975e80e9fdf10644a73
  type Width = GHC.Types.Int
1a69588f6ad4fd76020ab6544dec11ef
  concatHorizM ::
    Matrix.Matrix a -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
6352ebaa0c66619863611adc99773eec
  conhor ::
    Matrix.Matrix a
    -> Matrix.Matrix a -> GHC.Base.Maybe (Matrix.Matrix a)
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   (ds :: Matrix.Matrix a)
                   (ds1 :: Matrix.Matrix a) ->
                 case ds of wild {
                   Matrix.EmptyM -> Matrix.conhor1 @ a
                   Matrix.Matrix xs
                   -> case ds1 of wild1 {
                        Matrix.EmptyM -> Matrix.conhor1 @ a
                        Matrix.Matrix ys
                        -> case GHC.List.$wlenAcc @ [a] xs 0# of ww2 { DEFAULT ->
                           case GHC.List.$wlenAcc @ [a] ys 0# of ww1 { DEFAULT ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.==# ww2 ww1) of wild2 {
                             GHC.Types.False -> GHC.Base.Nothing @ (Matrix.Matrix a)
                             GHC.Types.True
                             -> GHC.Base.Just
                                  @ (Matrix.Matrix a)
                                  (Matrix.concatHorizM @ a wild wild1) } } } } }) -}
6bd4b20ad1117711d21e07940d520bd8
  conhor1 :: GHC.Base.Maybe (Matrix.Matrix a)
  {- Strictness: x -}
5d1cc566f51e23c59b9e205cc09cce11
  conver ::
    Matrix.Matrix a
    -> Matrix.Matrix a -> GHC.Base.Maybe (Matrix.Matrix a)
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   (ds :: Matrix.Matrix a)
                   (ds1 :: Matrix.Matrix a) ->
                 case ds of wild {
                   Matrix.EmptyM -> Matrix.conver1 @ a
                   Matrix.Matrix ds2
                   -> case ds2 of wild1 {
                        [] -> Matrix.conver1 @ a
                        : x xs
                        -> case ds1 of wild2 {
                             Matrix.EmptyM -> Matrix.conver1 @ a
                             Matrix.Matrix ds3
                             -> case ds3 of wild3 {
                                  [] -> Matrix.conver1 @ a
                                  : y ys
                                  -> case GHC.List.$wlenAcc @ a x 0# of ww2 { DEFAULT ->
                                     case GHC.List.$wlenAcc @ a y 0# of ww1 { DEFAULT ->
                                     case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.==# ww2 ww1) of wild4 {
                                       GHC.Types.False -> GHC.Base.Nothing @ (Matrix.Matrix a)
                                       GHC.Types.True
                                       -> GHC.Base.Just
                                            @ (Matrix.Matrix a)
                                            (Matrix.Matrix
                                               @ a
                                               (GHC.Base.++ @ [a] wild1 wild3)) } } } } } } }) -}
01af5cc431482e254b6c2de928c8b237
  conver1 :: GHC.Base.Maybe (Matrix.Matrix a)
  {- Strictness: x -}
f29f92dc36f0b8991a4b2d0b51cd6ef9
  deleteColumns ::
    [GHC.Types.Int] -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
135c8a94c296174c982055c5e2ea2ae1
  emptyM :: Matrix.Matrix a
  {- HasNoCafRefs,
     Unfolding: InlineRule (0, True, True) Matrix.EmptyM -}
05d9adba9f50fafc54f6c915eae3ef09
  filterLinesHor ::
    (a -> GHC.Types.Bool) -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, Strictness: <L,C(U)><L,1*U>,
     Unfolding: (\ @ a
                   (f :: a -> GHC.Types.Bool)
                   (eta :: Matrix.Matrix a) ->
                 Matrix.transposeM
                   @ a
                   (Matrix.Matrix
                      @ a
                      (case Matrix.transposeM @ a eta of wild {
                         Matrix.EmptyM -> case Matrix.$fEqMatrix1 ret_ty [[a]] of {}
                         Matrix.Matrix xs
                         -> GHC.List.filter
                              @ [a]
                              (\ (eta1 :: [a]) ->
                               letrec {
                                 go1 :: [a] -> Data.Monoid.All {- Arity: 1, Strictness: <S,1*U> -}
                                 = \ (ds :: [a]) ->
                                   case ds of wild1 {
                                     [] -> GHC.Types.True `cast` (Sym (Data.Monoid.N:All[0]))
                                     : y ys
                                     -> case f y of wild2 {
                                          GHC.Types.False
                                          -> GHC.Types.False `cast` (Sym (Data.Monoid.N:All[0]))
                                          GHC.Types.True -> go1 ys } }
                               } in
                               go1 eta1)
                                `cast`
                              (<[a]>_R ->_R Data.Monoid.N:All[0])
                              xs }))) -}
728924b6d1e54ccdea218be4c0e37878
  filterLinesVer ::
    (a -> GHC.Types.Bool) -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, Strictness: <L,C(U)><L,1*U>m2, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: a -> GHC.Types.Bool) (w1 :: Matrix.Matrix a) ->
                 case Matrix.$wfilterLinesVer @ a w w1 of ww { Unit# ww1 ->
                 Matrix.Matrix @ a ww1 }) -}
7e72a381fe66c589755119553dfed173
  findAMostQuadraticEdgeSize :: [a] -> (Matrix.Width, Matrix.Height)
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (xs :: [a]) ->
                 case Matrix.findEdgeSizes @ a xs of wild {
                   [] -> GHC.List.badHead @ (Matrix.Width, Matrix.Height)
                   : x ds1 -> x }) -}
b8991cce54422045ea545e6340de599d
  findEdgeSizes :: [a] -> [(Matrix.Width, Matrix.Height)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ @ a (xs :: [a]) ->
                 case GHC.List.$wlenAcc @ a xs 0# of ww2 { DEFAULT ->
                 let {
                   x :: GHC.Prim.Double#
                   = GHC.Prim.sqrtDouble# (GHC.Prim.int2Double# ww2)
                 } in
                 let {
                   n :: GHC.Prim.Int# = GHC.Prim.double2Int# x
                 } in
                 let {
                   $j :: GHC.Prim.Int# -> [(Matrix.Width, Matrix.Height)]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x1 :: GHC.Prim.Int#)[OneShot] ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.># x1 ww2) of wild {
                       GHC.Types.False
                       -> let {
                            lvl29 :: [GHC.Types.Int] = GHC.Enum.eftInt 1# ww2
                          } in
                          letrec {
                            go1 :: GHC.Prim.Int# -> [(Matrix.Width, Matrix.Height)]
                              {- Arity: 1, Strictness: <S,U> -}
                            = \ (x2 :: GHC.Prim.Int#) ->
                              let {
                                z :: [(Matrix.Width, Matrix.Height)]
                                = case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.==# x2 ww2) of wild1 {
                                    GHC.Types.False -> go1 (GHC.Prim.+# x2 1#)
                                    GHC.Types.True -> GHC.Types.[] @ (Matrix.Width, Matrix.Height) }
                              } in
                              let {
                                lvl30 :: GHC.Types.Int = GHC.Types.I# x2
                              } in
                              letrec {
                                go2 :: [GHC.Types.Int] -> [(Matrix.Width, Matrix.Height)]
                                  {- Arity: 1, Strictness: <S,1*U> -}
                                = \ (ds :: [GHC.Types.Int]) ->
                                  case ds of wild1 {
                                    [] -> z
                                    : y ys
                                    -> case y of wild2 { GHC.Types.I# y1 ->
                                       case GHC.Prim.tagToEnum#
                                              @ GHC.Types.Bool
                                              (GHC.Prim.==# (GHC.Prim.*# x2 y1) ww2) of wild3 {
                                         GHC.Types.False -> go2 ys
                                         GHC.Types.True
                                         -> GHC.Types.:
                                              @ (Matrix.Width, Matrix.Height)
                                              (lvl30, wild2)
                                              (go2 ys) } } }
                              } in
                              go2 lvl29
                          } in
                          go1 x1
                       GHC.Types.True -> GHC.Types.[] @ (Matrix.Width, Matrix.Height) }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<## x (GHC.Prim.int2Double# n)) of wild1 {
                   GHC.Types.False -> $j n
                   GHC.Types.True -> $j (GHC.Prim.-# n 1#) } }) -}
538cd10d354eb84c6068a8fb1a32ab05
  howManyElements :: Matrix.Matrix a -> GHC.Types.Int
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Matrix.Matrix a) ->
                 case Matrix.$whowManyElements @ a w of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
2c30e51d3f5486a40bf4ded014d5d450
  howManyElements1 :: GHC.Types.Int
  {- Strictness: x -}
6f3794f8d456a64c3211120db512d14c
  normalize :: Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a (x :: Matrix.Matrix a) ->
                 let {
                   xs :: [a] = Matrix.toList @ a x
                 } in
                 Matrix.toRectMatrix
                   @ a
                   (Matrix.normalize2 @ a xs)
                   (Matrix.normalize1 @ a xs)
                   xs) -}
1f69d04112fe9a973da02856f015080d
  normalize1 :: [a] -> Matrix.Height
  {- Arity: 1, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (x :: [a]) ->
                 case Matrix.findEdgeSizes @ a x of wild {
                   [] -> case GHC.List.badHead ret_ty Matrix.Height of {}
                   : x1 ds1 -> case x1 of wild1 { (,) ds2 y -> y } }) -}
b2e1733350af4d3492a7db5a5d5e47e6
  normalize2 :: [a] -> Matrix.Width
  {- Arity: 1, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (x :: [a]) ->
                 case Matrix.findEdgeSizes @ a x of wild {
                   [] -> case GHC.List.badHead ret_ty Matrix.Width of {}
                   : x1 ds1 -> case x1 of wild1 { (,) x2 ds2 -> x2 } }) -}
b737533cbcd245975feced599b49bbf0
  toASquareMatrix :: [a] -> Matrix.Matrix a
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (xs :: [a]) ->
                 Matrix.toRectMatrix
                   @ a
                   (Matrix.normalize2 @ a xs)
                   (Matrix.normalize1 @ a xs)
                   xs) -}
a5c5b16bc9e1568ee375166210fe73a7
  toHeightMatrix :: Matrix.Height -> [a] -> Matrix.Matrix a
  {- Arity: 2, Strictness: <L,U(U)><S,U>,
     Unfolding: (\ @ a (height :: Matrix.Height) (xs :: [a]) ->
                 Matrix.toRectMatrix
                   @ a
                   (case GHC.List.$wlenAcc @ a xs 0# of ww2 { DEFAULT ->
                    case height of ww1 { GHC.Types.I# ww3 ->
                    case ww3 of wild {
                      DEFAULT
                      -> case GHC.Prim.quotInt# ww2 wild of ww4 { DEFAULT ->
                         GHC.Types.I# ww4 }
                      -1#
                      -> case ww2 of wild1 {
                           DEFAULT -> GHC.Types.I# (GHC.Prim.quotInt# wild1 -1#)
                           -9223372036854775808#
                           -> case GHC.Real.overflowError ret_ty Matrix.Width of {} }
                      0# -> case GHC.Real.divZeroError ret_ty Matrix.Width of {} } } })
                   height
                   xs) -}
d8308d270ad863abb1738ee71877b00c
  toList :: Matrix.Matrix a -> [a]
  {- Arity: 1, Strictness: <S,1*U> -}
59625c20e696b1814205a34fbd9b96d8
  toRectMatrix ::
    Matrix.Width -> Matrix.Height -> [a] -> Matrix.Matrix a
  {- Arity: 3, Strictness: <L,1*U(1*U)><L,U(U)><S,1*U> -}
da4988ece597c0e5952893b053b5093c
  transposeM :: Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 1, Strictness: <S,1*U> -}
420f916b3b182de953b8bc6ef10b2eb1
  vector :: [a] -> Matrix.Axis -> Matrix.Matrix a
  {- Arity: 2, Strictness: <S,1*U><L,1*U(1*U)>,
     Unfolding: (\ @ a (ds :: [a]) (ds1 :: Matrix.Axis) ->
                 case ds of wild {
                   [] -> Matrix.EmptyM @ a
                   : ipv ipv1
                   -> case ds1 of wild1 { GHC.Types.I# ds2 ->
                      case ds2 of ds3 {
                        DEFAULT -> Matrix.vector1 @ a
                        0#
                        -> Matrix.Matrix @ a (GHC.Types.: @ [a] wild (GHC.Types.[] @ [a]))
                        1#
                        -> Matrix.Matrix
                             @ a
                             (case Matrix.$wmakeListOfOneElementLists
                                     @ a
                                     wild of ww { (#,#) ww1 ww2 ->
                              GHC.Types.: @ [a] ww1 ww2 }) } } }) -}
d57ea2b065eb1ef18be969238d6467f1
  vector1 :: Matrix.Matrix a
  {- Strictness: x -}
1eb8fb7b36d6af0ea8d892b9d4e7d4b8
  zipWithLines :: (a -> a -> a) -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ a (f :: a -> a -> a) (ds :: Matrix.Matrix a) ->
                 case ds of wild {
                   Matrix.EmptyM -> Matrix.zipWithLines1 @ a
                   Matrix.Matrix ds1
                   -> case ds1 of wild1 {
                        [] -> Matrix.zipWithLines1 @ a
                        : x xs
                        -> letrec {
                             go1 :: [[a]] -> [a] {- Arity: 1, Strictness: <S,1*U> -}
                             = \ (ds2 :: [[a]]) ->
                               case ds2 of wild2 {
                                 [] -> x : y ys -> GHC.List.zipWith @ a @ a @ a f y (go1 ys) }
                           } in
                           case go1 xs of wild2 {
                             [] -> Matrix.EmptyM @ a
                             : ipv ipv1
                             -> Matrix.Matrix
                                  @ a
                                  (GHC.Types.: @ [a] wild2 (GHC.Types.[] @ [a])) } } }) -}
295505a7765b65ad97ddb8eba944b2c9
  zipWithLines1 :: Matrix.Matrix a
  {- Strictness: x -}
da4988ece597c0e5952893b053b5093c
  zipWithM ::
    (a -> b -> c)
    -> Matrix.Matrix a -> Matrix.Matrix b -> Matrix.Matrix c
  {- Arity: 3, Strictness: <L,C(C1(U))><S,1*U><S,1*U> -}
instance [safe] GHC.Classes.Eq [Matrix.Matrix] = Matrix.$fEqMatrix
instance [safe] GHC.Base.Functor [Matrix.Matrix]
  = Matrix.$fFunctorMatrix
instance [safe] GHC.Num.Num [Matrix.Matrix] = Matrix.$fNumMatrix
instance [safe] GHC.Show.Show [Matrix.Matrix] = Matrix.$fShowMatrix
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

