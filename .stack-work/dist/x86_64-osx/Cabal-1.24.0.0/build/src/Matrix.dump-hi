
==================== FINAL INTERFACE ====================
2017-01-20 18:51:00.117625 UTC

interface Regression-0.1.0.0-5YhMFDRIyA3ESfKGYZUQrM:Matrix 8001
  interface hash: 5e1dcc31052fef286589857d84e668ea
  ABI hash: d691c83993c7fb261954057918d1a977
  export-list hash: bfac6313be8ca5112bae8e928a0cdca0
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: a4046e0fdab24403354cf30558c1ea1c
  sig of: Nothing
  used TH splices: False
  where
exports:
  Matrix.conhor
  Matrix.conver
  Matrix.deleteColumns
  Matrix.emptyM
  Matrix.filterLinesHor
  Matrix.filterLinesVer
  Matrix.findAMostQuadraticEdgeSize
  Matrix.findEdgeSizes
  Matrix.getAvgColumnsMatrix
  Matrix.getColumn
  Matrix.getElementByInd
  Matrix.getHeight
  Matrix.getRangeColumnsMatrix
  Matrix.getRow
  Matrix.getSize
  Matrix.getWidth
  Matrix.howManyElements
  Matrix.isEmpty
  Matrix.normalize
  Matrix.packM
  Matrix.scaleLines
  Matrix.toASquareMatrix
  Matrix.toHeightMatrix
  Matrix.toList
  Matrix.toRectMatrix
  Matrix.transposeM
  Matrix.unpackM
  Matrix.vector
  Matrix.zipWithLines
  Matrix.zipWithM
  Matrix.Matrix
module dependencies: MaybeResult
package dependencies: base-4.9.0.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Either base-4.9.0.0:Data.Functor.Const
                         base-4.9.0.0:Data.Monoid base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:GHC.Generics base-4.9.0.0:GHC.IO.Exception
                         base-4.9.0.0:GHC.TypeLits
import  -/  MaybeResult 8178d3796ce41b92c45fe2a3a59324c1
  exports: 9a7fc92e06f15e57b81de331908698d7
  Error 7f26ccbab2b8244905bebce7b89192de
  JustRes f7114d04ba3bad9547105c99fba6e324
  MaybeRes 82801d3acd199b30ac7c2d6157ea688c
  getError 64eb76030ba685ad3d92ca8c64d1aaa2
  getResult bd03e0529b9c99578a720144aa0941fd
  isOK 18c4e730488af3a52c3a510ff1033546
import  -/  base-4.9.0.0:Data.Foldable 8aeb682f6c74f97fcf0ace0d608a43ea
import  -/  base-4.9.0.0:Data.List 49b86831b79b49ce5d4d9416ecba61df
import  -/  base-4.9.0.0:Data.OldList 0058409f994fb13ae0616e3f1e5b4dae
import  -/  base-4.9.0.0:Data.Tuple acb0ed10307ed88df6c81b8589f4de16
import  -/  base-4.9.0.0:GHC.Base 8ed3be81c0707b322f975a84ae1bb816
import  -/  base-4.9.0.0:GHC.Err 3bba35a16538d33d424682ce66876cdd
import  -/  base-4.9.0.0:GHC.Float 469226b1bc53433e95d0167dec5d0312
import  -/  base-4.9.0.0:GHC.List 13d2451194c1c6e53b4f4f07947736dd
import  -/  base-4.9.0.0:GHC.Num 48f506a8f4ecf06285d0a0706594dcc0
import  -/  base-4.9.0.0:GHC.Real 08bf4acb5f2508f89d6fbcd57fe232e9
import  -/  base-4.9.0.0:GHC.Show 952347a6ab730bcb25c0854d8bc6ca51
import  -/  base-4.9.0.0:Prelude b9bddb97799837fe67a8d00939a5b6c3
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
02b27f11c61bc20edf880b673c1d3478
  $fEqMatrix :: GHC.Classes.Eq a => GHC.Classes.Eq (Matrix.Matrix a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dEq :: GHC.Classes.Eq a).
                  @ (Matrix.Matrix a)
                  (Matrix.$fEqMatrix_$c== @ a $dEq)
                  (Matrix.$fEqMatrix_$c/= @ a $dEq) -}
1dc2aacc19e6d2b160f4dc932555d62c
  $fEqMatrix1 :: Matrix.Height
  {- Unfolding: (\ @ a ->
                 case GHC.List.$wlenAcc
                        @ a
                        (GHC.Types.[] @ a)
                        0# of ww2 { DEFAULT ->
                 GHC.Types.I# ww2 }) -}
891abb8e695ea5e0ac170f0f343965be
  $fEqMatrix2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
1021bc582cab4a9f389a11dc611ae84b
  $fEqMatrix3 :: (Matrix.Width, Matrix.Height)
  {- Strictness: x -}
02b27f11c61bc20edf880b673c1d3478
  $fEqMatrix_$c/= ::
    GHC.Classes.Eq a =>
    Matrix.Matrix a -> Matrix.Matrix a -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (x :: Matrix.Matrix a)
                   (y :: Matrix.Matrix a) ->
                 GHC.Classes.not (Matrix.$fEqMatrix_$c== @ a $dEq x y)) -}
02b27f11c61bc20edf880b673c1d3478
  $fEqMatrix_$c== ::
    GHC.Classes.Eq a =>
    Matrix.Matrix a -> Matrix.Matrix a -> GHC.Types.Bool
  {- Arity: 3,
     Strictness: <L,1*U(1*C(C1(U)),A)><S(S),U(U)><S(S),U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Classes.Eq a)
                   (w1 :: Matrix.Matrix a)
                   (w2 :: Matrix.Matrix a) ->
                 case w1 of ww { Matrix.Matrix ww1 ->
                 case w2 of ww2 { Matrix.Matrix ww3 ->
                 Matrix.$w$c== @ a w ww1 ww3 } }) -}
55963e7136ef1f92afef67cb01939391
  $fEqMatrix_go :: [[GHC.Types.Bool]] -> Data.Monoid.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
02b27f11c61bc20edf880b673c1d3478
  $fFunctorMatrix :: GHC.Base.Functor Matrix.Matrix
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Matrix.Matrix
                  Matrix.$fFunctorMatrix_$cfmap
                  Matrix.$fFunctorMatrix_$c<$ -}
02b27f11c61bc20edf880b673c1d3478
  $fFunctorMatrix_$c<$ :: a -> Matrix.Matrix b -> Matrix.Matrix a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S(S),1*U(1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (eta :: a) (eta1 :: Matrix.Matrix b) ->
                 Matrix.$fFunctorMatrix_$cfmap @ b @ a (\ (ds :: b) -> eta) eta1) -}
02b27f11c61bc20edf880b673c1d3478
  $fFunctorMatrix_$cfmap ::
    (a -> b) -> Matrix.Matrix a -> Matrix.Matrix b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S(S),1*U(1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (w :: a -> b) (w1 :: Matrix.Matrix a) ->
                 case w1 of ww { Matrix.Matrix ww1 ->
                 case Matrix.$w$cfmap @ a @ b w ww1 of ww2 { Unit# ww3 ->
                 Matrix.Matrix @ b ww3 } }) -}
02b27f11c61bc20edf880b673c1d3478
  $fNumMatrix :: GHC.Num.Num a => GHC.Num.Num (Matrix.Matrix a)
  DFunId
  {- Arity: 1,
     Strictness: <L,U(C(C1(U)),A,C(C1(U)),C(U),C(U),C(U),C(U))>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dNum :: GHC.Num.Num a).
                  @ (Matrix.Matrix a)
                  (Matrix.$fNumMatrix_$c+ @ a $dNum)
                  (Matrix.$fNumMatrix_$c- @ a $dNum)
                  (Matrix.$fNumMatrix_$c* @ a $dNum)
                  (Matrix.$fNumMatrix_$cnegate @ a $dNum)
                  (Matrix.$fNumMatrix_$cabs @ a $dNum)
                  (Matrix.$fNumMatrix_$csignum @ a $dNum)
                  (Matrix.$fNumMatrix_$cfromInteger @ a $dNum) -}
02b27f11c61bc20edf880b673c1d3478
  $fNumMatrix1 :: GHC.Num.Num a => [[a]] -> [[a]] -> Matrix.Matrix a
  {- Arity: 3, Strictness: <L,U><L,U><L,U>x -}
02b27f11c61bc20edf880b673c1d3478
  $fNumMatrix_$c* ::
    GHC.Num.Num a =>
    Matrix.Matrix a -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,C(C1(U)),A,A,A,C(U))><S(S),U(U)><S(S),U(U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Num.Num a)
                   (w1 :: Matrix.Matrix a)
                   (w2 :: Matrix.Matrix a) ->
                 case w1 of ww { Matrix.Matrix ww1 ->
                 case w2 of ww2 { Matrix.Matrix ww3 ->
                 case Matrix.$w$c* @ a w ww1 ww3 of ww4 { Unit# ww5 ->
                 Matrix.Matrix @ a ww5 } } }) -}
02b27f11c61bc20edf880b673c1d3478
  $fNumMatrix_$c+ ::
    GHC.Num.Num a =>
    Matrix.Matrix a -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,A,A,A,A,A)><S(S),U(U)><S(S),U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Num.Num a)
                   (w1 :: Matrix.Matrix a)
                   (w2 :: Matrix.Matrix a) ->
                 case w1 of ww { Matrix.Matrix ww1 ->
                 case w2 of ww2 { Matrix.Matrix ww3 ->
                 Matrix.$w$c+ @ a w ww1 ww3 } }) -}
02b27f11c61bc20edf880b673c1d3478
  $fNumMatrix_$c- ::
    GHC.Num.Num a =>
    Matrix.Matrix a -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,C(C1(U)),C(U),C(U),C(U),C(U))><L,U><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ a
                   ($dNum :: GHC.Num.Num a)
                   (x :: Matrix.Matrix a)
                   (y :: Matrix.Matrix a) ->
                 Matrix.$fNumMatrix_$c+
                   @ a
                   $dNum
                   x
                   (Matrix.$fNumMatrix_$cnegate @ a $dNum y)) -}
02b27f11c61bc20edf880b673c1d3478
  $fNumMatrix_$cabs ::
    GHC.Num.Num a => Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(A,A,A,A,1*C(U),A,A)><S(S),1*U(1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) (eta :: Matrix.Matrix a) ->
                 Matrix.$fFunctorMatrix_$cfmap
                   @ a
                   @ a
                   (GHC.Num.abs @ a $dNum)
                   eta) -}
02b27f11c61bc20edf880b673c1d3478
  $fNumMatrix_$cfromInteger ::
    GHC.Num.Num a => GHC.Integer.Type.Integer -> Matrix.Matrix a
  {- Arity: 2, Strictness: <L,1*U(A,A,A,A,A,A,1*C1(U))><L,U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Num.Num a) (w1 :: GHC.Integer.Type.Integer) ->
                 case Matrix.$w$cfromInteger @ a w w1 of ww { Unit# ww1 ->
                 Matrix.Matrix @ a ww1 }) -}
02b27f11c61bc20edf880b673c1d3478
  $fNumMatrix_$cnegate ::
    GHC.Num.Num a => Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(A,A,A,1*C(U),A,A,A)><S(S),1*U(1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) (eta :: Matrix.Matrix a) ->
                 Matrix.$fFunctorMatrix_$cfmap
                   @ a
                   @ a
                   (GHC.Num.negate @ a $dNum)
                   eta) -}
02b27f11c61bc20edf880b673c1d3478
  $fNumMatrix_$csignum ::
    GHC.Num.Num a => Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(A,A,A,A,A,1*C(U),A)><S(S),1*U(1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) (eta :: Matrix.Matrix a) ->
                 Matrix.$fFunctorMatrix_$cfmap
                   @ a
                   @ a
                   (GHC.Num.signum @ a $dNum)
                   eta) -}
02b27f11c61bc20edf880b673c1d3478
  $fShowMatrix :: GHC.Show.Show a => GHC.Show.Show (Matrix.Matrix a)
  DFunId
  {- Arity: 1, Strictness: <L,U(A,U,A)>m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dShow :: GHC.Show.Show a).
                  @ (Matrix.Matrix a)
                  (Matrix.$fShowMatrix_$cshowsPrec @ a $dShow)
                  (Matrix.$fShowMatrix_$cshow @ a $dShow)
                  (Matrix.$fShowMatrix_$cshowList @ a $dShow) -}
ca65112db879b36120570c113806c382
  $fShowMatrix1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# " "#) -}
ce1cb345dfe7e0fc19e967522265af14
  $fShowMatrix2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "\n"#) -}
19e8801acdb42d68702dd544d2328e33
  $fShowMatrix3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Empty matrix."#) -}
02b27f11c61bc20edf880b673c1d3478
  $fShowMatrix_$cshow ::
    GHC.Show.Show a => Matrix.Matrix a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(A,1*U,A)><S(S),1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Show.Show a) (w1 :: Matrix.Matrix a) ->
                 case w1 of ww { Matrix.Matrix ww1 ->
                 Matrix.$w$cshow @ a w ww1 }) -}
02b27f11c61bc20edf880b673c1d3478
  $fShowMatrix_$cshowList ::
    GHC.Show.Show a => [Matrix.Matrix a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(A,U,A)><S,1*U><L,U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [Matrix.Matrix a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Matrix.Matrix a)
                   (\ (x :: Matrix.Matrix a) (s1 :: GHC.Base.String)[OneShot] ->
                    case x of ww { Matrix.Matrix ww1 ->
                    GHC.Base.++ @ GHC.Types.Char (Matrix.$w$cshow @ a $dShow ww1) s1 })
                   ls
                   s) -}
02b27f11c61bc20edf880b673c1d3478
  $fShowMatrix_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> Matrix.Matrix a -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <L,1*U(A,1*U,A)><L,A><S(S),1*U(U)><L,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ds :: GHC.Types.Int)
                   (x :: Matrix.Matrix a)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Matrix.$fShowMatrix_$cshow @ a $dShow x))
                   s) -}
d81aa6841d7de93a4cf927542edb5c2b
  $fShowMatrix_z :: [GHC.Types.Char]
  {- Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   Matrix.$fShowMatrix2
                   (GHC.Types.[] @ GHC.Types.Char)) -}
d4e8a9d66412dd6fcfb8c780e7e7ba1f
  $tc'Matrix :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6115875564321221083##
                   2356641421694218291##
                   Matrix.$trModule
                   Matrix.$tc'Matrix1) -}
d2b4067e1654c15b00f78bbd7c925ed4
  $tc'Matrix1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Matrix"#) -}
9763c23a3e0dc7b9fd52634da83c7666
  $tcMatrix :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8970019815648942656##
                   17693700896870124416##
                   Matrix.$trModule
                   Matrix.$trModule1) -}
1078b542baee10325365d9c33a6ace95
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Matrix.$trModule2
                   Matrix.$trModule1) -}
9385be0fbf7b63f4ff71eaf34dc4a1d3
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Matrix"#) -}
870d19cbc54c3a2dcf387f8e3b14ac01
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "Regression-0.1.0.0-5YhMFDRIyA3ESfKGYZUQrM"#) -}
02b27f11c61bc20edf880b673c1d3478
  $w$c* :: GHC.Num.Num a => [[a]] -> [[a]] -> (# [[a]] #)
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,C(C1(U)),A,A,A,C(U))><S,U><S,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Num.Num a)
                   (ww :: [[a]])
                   (ww1 :: [[a]]) ->
                 case Matrix.$wgetSize @ a ww of ww2 { (#,#) ww3 ww4 ->
                 case ww4 of wild { GHC.Types.I# x ->
                 case Matrix.$wgetSize @ a ww1 of ww5 { (#,#) ww6 ww7 ->
                 case ww6 of wild1 { GHC.Types.I# y ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# x y) of wild2 {
                   GHC.Types.False
                   -> case Matrix.$wlvl @ a ww ww1 ret_ty (# [[a]] #) of {}
                   GHC.Types.True
                   -> case Matrix.$wtransposeM @ a ww of ww8 { Unit# ww9 ->
                      case Matrix.$wmulling @ a w ww9 ww1 of ww10 { Matrix.Matrix ww11 ->
                      Matrix.$wtransposeM @ a ww11 } } } } } } }) -}
02b27f11c61bc20edf880b673c1d3478
  $w$c+ :: GHC.Num.Num a => [[a]] -> [[a]] -> Matrix.Matrix a
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A,A,A,A,A)><S,U><S,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Num.Num a)
                   (ww :: [[a]])
                   (ww1 :: [[a]]) ->
                 case Matrix.$wzipWithM
                        @ a
                        @ a
                        @ a
                        (GHC.Num.+ @ a w)
                        ww
                        ww1 of wild {
                   MaybeResult.JustRes ds -> ds
                   MaybeResult.Error ds -> Matrix.$fNumMatrix1 @ a w ww ww1 }) -}
02b27f11c61bc20edf880b673c1d3478
  $w$c== :: GHC.Classes.Eq a => [[a]] -> [[a]] -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,1*U(1*C(C1(U)),A)><S,U><S,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Classes.Eq a)
                   (ww :: [[a]])
                   (ww1 :: [[a]]) ->
                 case Matrix.$wgetSize @ a ww of ww2 { (#,#) ww3 ww4 ->
                 case Matrix.$wgetSize @ a ww1 of ww5 { (#,#) ww6 ww7 ->
                 case ww3 of wild { GHC.Types.I# x ->
                 case ww6 of wild1 { GHC.Types.I# y ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# x y) of wild2 {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case ww4 of wild3 { GHC.Types.I# x1 ->
                      case ww7 of wild4 { GHC.Types.I# y1 ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# x1 y1) of wild5 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> case Matrix.$wzipWithM
                                  @ a
                                  @ a
                                  @ GHC.Types.Bool
                                  (GHC.Classes.== @ a w)
                                  ww
                                  ww1 of wild6 {
                             MaybeResult.JustRes x2
                             -> case x2 of wild7 { Matrix.Matrix xs ->
                                (Matrix.$fEqMatrix_go xs) `cast` (Data.Monoid.N:All[0]) }
                             MaybeResult.Error ipv
                             -> case MaybeResult.getResult1
                                       @ (Matrix.Matrix GHC.Types.Bool)
                                       wild6
                                ret_ty GHC.Types.Bool
                                of {} } } } } } } } } }) -}
a32d10e6dcf3097ca1c08559a450f623
  $w$cfmap :: (a -> b) -> [[a]] -> (# [[b]] #)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Inline: [0] -}
4cac548522f82bfebc6fd98f321f19e7
  $w$cfromInteger ::
    GHC.Num.Num a => GHC.Integer.Type.Integer -> (# [[a]] #)
  {- Arity: 2, Strictness: <L,1*U(A,A,A,A,A,A,1*C1(U))><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Num.Num a)
                   (w1 :: GHC.Integer.Type.Integer) ->
                 let {
                   xs :: a = GHC.Num.fromInteger @ a w w1
                 } in
                 let {
                   xs1 :: [a] = GHC.Types.: @ a xs (GHC.Types.[] @ a)
                 } in
                 Matrix.$wtoRectMatrix
                   @ a
                   (case Matrix.findEdgeSizes @ a xs1 of wild {
                      [] -> case GHC.List.badHead ret_ty Matrix.Width of {}
                      : x ds1 -> case x of wild1 { (,) x1 ds2 -> x1 } })
                   (case Matrix.findEdgeSizes @ a xs1 of wild {
                      [] -> case GHC.List.badHead ret_ty Matrix.Height of {}
                      : x ds1 -> case x of wild1 { (,) ds2 y -> y } })
                   xs1) -}
48b0954ecd02d28c9e3ec881af990a42
  $w$cshow :: GHC.Show.Show a => [[a]] -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(A,1*U,A)><S,U>, Inline: [0],
     Unfolding: (\ @ a (w :: GHC.Show.Show a) (ww :: [[a]]) ->
                 case ww of wild {
                   [] -> Matrix.$fShowMatrix3
                   : ipv ipv1
                   -> case Matrix.$wtransposeM @ a wild of ww1 { Unit# ww2 ->
                      let {
                        g :: a -> [GHC.Types.Char] = GHC.Show.show @ a w
                      } in
                      letrec {
                        go1 :: [a] -> [GHC.Types.Char] {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds :: [a]) ->
                          case ds of wild1 {
                            [] -> Matrix.$fShowMatrix_z
                            : y ys
                            -> GHC.Base.++
                                 @ GHC.Types.Char
                                 (GHC.Base.++ @ GHC.Types.Char (g y) Matrix.$fShowMatrix1)
                                 (go1 ys) }
                      } in
                      letrec {
                        go2 :: [[a]] -> [GHC.Types.Char]
                          {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds :: [[a]]) ->
                          case ds of wild1 {
                            [] -> GHC.Types.[] @ GHC.Types.Char
                            : y ys -> GHC.Base.++ @ GHC.Types.Char (go1 y) (go2 ys) }
                      } in
                      go2 ww2 } }) -}
0d5b868bf0fbb2bd2563cd21c3cfe620
  $wconcatHorizM :: [[a]] -> [[a]] -> (# [[a]] #)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,U>, Inline: [0] -}
fb715a2a78aae60603e4ddd178952e08
  $wconhor ::
    [[a]] -> [[a]] -> MaybeResult.MaybeRes (Matrix.Matrix a)
  {- Arity: 2, Strictness: <S,U><S,U>, Inline: [0],
     Unfolding: (\ @ a (ww :: [[a]]) (ww1 :: [[a]]) ->
                 case GHC.List.$wlenAcc @ [a] ww 0# of ww2 { DEFAULT ->
                 case GHC.List.$wlenAcc @ [a] ww1 0# of ww3 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# ww2 ww3) of wild {
                   GHC.Types.False -> Matrix.conhor1 @ a
                   GHC.Types.True
                   -> MaybeResult.JustRes
                        @ (Matrix.Matrix a)
                        (case Matrix.$wconcatHorizM @ a ww ww1 of ww4 { Unit# ww5 ->
                         Matrix.Matrix @ a ww5 }) } } }) -}
2512711a8d2f78a9ea9c385d0e9639a5
  $wconver ::
    [[a]] -> [[a]] -> MaybeResult.MaybeRes (Matrix.Matrix a)
  {- Arity: 2, Strictness: <S,U><S,U>, Inline: [0],
     Unfolding: (\ @ a (ww :: [[a]]) (ww1 :: [[a]]) ->
                 case ww of wild {
                   []
                   -> case ww1 of wild1 {
                        [] -> Matrix.conver3 @ a
                        : ipv ipv1
                        -> MaybeResult.JustRes
                             @ (Matrix.Matrix a)
                             (Matrix.Matrix @ a wild1) }
                   : ipv ipv1
                   -> case ww1 of wild1 {
                        []
                        -> MaybeResult.JustRes @ (Matrix.Matrix a) (Matrix.Matrix @ a wild)
                        : ipv2 ipv3
                        -> case GHC.List.$wlenAcc @ a ipv 0# of ww2 { DEFAULT ->
                           case GHC.List.$wlenAcc @ a ipv2 0# of ww3 { DEFAULT ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.==# ww2 ww3) of wild2 {
                             GHC.Types.False -> Matrix.conver1 @ a
                             GHC.Types.True
                             -> MaybeResult.JustRes
                                  @ (Matrix.Matrix a)
                                  (Matrix.Matrix @ a (GHC.Base.++ @ [a] wild wild1)) } } } } }) -}
c6d0f22738a7b9c2f1d8b06082174055
  $wdeleteColumns :: [GHC.Types.Int] -> [[a]] -> (# [[a]] #)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [0] -}
dce7bfedefb5b1b5441b56ab67413779
  $wfilterLinesHor :: (a -> GHC.Types.Bool) -> [[a]] -> (# [[a]] #)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ a (w :: a -> GHC.Types.Bool) (ww :: [[a]]) ->
                 case Matrix.$wtransposeM @ a ww of ww1 { Unit# ww2 ->
                 Matrix.$wtransposeM
                   @ a
                   (GHC.List.filter
                      @ [a]
                      (\ (eta :: [a]) ->
                       letrec {
                         go1 :: [a] -> Data.Monoid.All {- Arity: 1, Strictness: <S,1*U> -}
                         = \ (ds :: [a]) ->
                           case ds of wild {
                             [] -> GHC.Types.True `cast` (Sym (Data.Monoid.N:All[0]))
                             : y ys
                             -> case w y of wild1 {
                                  GHC.Types.False
                                  -> GHC.Types.False `cast` (Sym (Data.Monoid.N:All[0]))
                                  GHC.Types.True -> go1 ys } }
                       } in
                       go1 eta)
                        `cast`
                      (<[a]>_R ->_R Data.Monoid.N:All[0])
                      ww2) }) -}
65c11c44d83cd821dd5db29751b89ef4
  $wfilterLinesVer ::
    (a -> GHC.Types.Bool) -> Matrix.Matrix a -> (# [[a]] #)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><L,1*U(1*U)>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: a -> GHC.Types.Bool)
                   (w1 :: Matrix.Matrix a) ->
                 (# case w1 of wild { Matrix.Matrix xs ->
                    GHC.List.filter
                      @ [a]
                      (\ (eta :: [a]) ->
                       letrec {
                         go1 :: [a] -> Data.Monoid.All {- Arity: 1, Strictness: <S,1*U> -}
                         = \ (ds :: [a]) ->
                           case ds of wild1 {
                             [] -> GHC.Types.True `cast` (Sym (Data.Monoid.N:All[0]))
                             : y ys
                             -> case w y of wild2 {
                                  GHC.Types.False
                                  -> GHC.Types.False `cast` (Sym (Data.Monoid.N:All[0]))
                                  GHC.Types.True -> go1 ys } }
                       } in
                       go1 eta)
                        `cast`
                      (<[a]>_R ->_R Data.Monoid.N:All[0])
                      xs } #)) -}
b752a5b00a7c402fb067469790d4645d
  $wgetAvgRangeAboutColumns ::
    (GHC.Real.Fractional a, GHC.Real.Real a) =>
    [[a]] -> Matrix.Matrix (a, a)
  {- Arity: 3,
     Strictness: <L,U(U,C(C1(U)),A,C(U))><L,U(U,U,C(U))><S,1*U>,
     Inline: [0] -}
7e11460377b19bda7c959cdfc15ecccf
  $wgetElementByInd ::
    GHC.Prim.Int# -> Matrix.Height -> [[a]] -> MaybeResult.MaybeRes a
  {- Arity: 3, Strictness: <S,U><L,U(U)><S,U>, Inline: [0] -}
8616f4167cc1c4a5ae9a8ca857cb5a4b
  $wgetSize :: [[a]] -> (# Matrix.Width, Matrix.Height #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ @ a (ww :: [[a]]) ->
                 case ww of wild {
                   []
                   -> case Matrix.$fEqMatrix3
                      ret_ty (# Matrix.Width, Matrix.Height #)
                      of {}
                   : ds ds1
                   -> case ds of wild1 {
                        []
                        -> case ds1 of wild2 {
                             [] -> (# Matrix.$fEqMatrix2, Matrix.$fEqMatrix2 #)
                             : ipv ipv1
                             -> (# case GHC.List.$wlenAcc
                                          @ [a]
                                          (GHC.Types.: @ [a] (GHC.Types.[] @ a) wild2)
                                          0# of ww2 { DEFAULT ->
                                   GHC.Types.I# ww2 },
                                   Matrix.$fEqMatrix1 @ a #) }
                        : ipv ipv1
                        -> (# case GHC.List.$wlenAcc @ [a] wild 0# of ww2 { DEFAULT ->
                              GHC.Types.I# ww2 },
                              case GHC.List.$wlenAcc @ a wild1 0# of ww2 { DEFAULT ->
                              GHC.Types.I# ww2 } #) } }) -}
8997eca91db915a5b0d60d2ad4bf1cf2
  $whowManyElements :: [[a]] -> GHC.Prim.Int#
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ @ a (ww :: [[a]]) ->
                 case ww of wild {
                   [] -> case Matrix.howManyElements1 ret_ty GHC.Prim.Int# of {}
                   : x xs
                   -> case GHC.List.$wlenAcc @ a x 0# of ww2 { DEFAULT ->
                      case GHC.List.$wlenAcc @ [a] xs 0# of ww1 { DEFAULT ->
                      GHC.Prim.*# ww2 (GHC.Prim.+# ww1 1#) } } }) -}
02b27f11c61bc20edf880b673c1d3478
  $wlvl :: [[a]] -> [[a]] -> Matrix.Matrix a
  {- Arity: 2, Strictness: <B,1*U><B,1*U>x, Inline: [0] -}
c31016749675d5aa4dbe86e7bbfd85d7
  $wmakeListOfOneElementLists :: [a] -> (# [a], [[a]] #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
02b27f11c61bc20edf880b673c1d3478
  $wmulling :: GHC.Num.Num a => [[a]] -> [[a]] -> Matrix.Matrix a
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,C(C1(U)),A,A,A,C(U))><S,1*U><L,U>,
     Inline: [0] -}
76d4a506796a67716ada2bd18686c73f
  $wnormalize :: [[a]] -> (# [[a]] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ @ a (ww :: [[a]]) ->
                 let {
                   xs :: [a] = Matrix.$wtoList @ a ww
                 } in
                 Matrix.$wtoRectMatrix
                   @ a
                   (Matrix.normalize2 @ a xs)
                   (Matrix.normalize1 @ a xs)
                   xs) -}
11f4670a9542b52b5ed1213e38bbdb7e
  $wscaleLines ::
    (GHC.Real.Fractional a, GHC.Real.Real a) =>
    [[a]] -> Matrix.Matrix a
  {- Arity: 3,
     Strictness: <L,U(U,C(C1(U)),A,C(U))><L,U(U,U,C(U))><S,1*U>,
     Inline: [0] -}
cca3f8c5b370892f2586f509acc725a0
  $wtoHeightMatrix :: Matrix.Height -> [a] -> (# [[a]] #)
  {- Arity: 2, Strictness: <L,U(U)><S,U>, Inline: [0],
     Unfolding: (\ @ a (w :: Matrix.Height) (w1 :: [a]) ->
                 Matrix.$wtoRectMatrix
                   @ a
                   (case GHC.List.$wlenAcc @ a w1 0# of ww2 { DEFAULT ->
                    case w of ww1 { GHC.Types.I# ww3 ->
                    case ww3 of wild {
                      DEFAULT
                      -> case GHC.Prim.quotInt# ww2 wild of ww4 { DEFAULT ->
                         GHC.Types.I# ww4 }
                      -1#
                      -> case ww2 of wild1 {
                           DEFAULT -> GHC.Types.I# (GHC.Prim.quotInt# wild1 -1#)
                           -9223372036854775808#
                           -> case GHC.Real.overflowError ret_ty Matrix.Width of {} }
                      0# -> case GHC.Real.divZeroError ret_ty Matrix.Width of {} } } })
                   w
                   w1) -}
fa3c99f7f3b4c9a17591f84341be294d
  $wtoList :: [[a]] -> [a]
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
cff5104a7d145da83bd52fa6e1e68107
  $wtoRectMatrix ::
    Matrix.Width -> Matrix.Height -> [a] -> (# [[a]] #)
  {- Arity: 3, Strictness: <L,1*U(1*U)><L,U(U)><S,1*U>,
     Inline: [0] -}
4f9094c41ab880ef8b0844d93a2e1d28
  $wtransposeM :: [[a]] -> (# [[a]] #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
fcd35e2a32ff2967cb260a0e121883cb
  $wzipWithLines :: (a -> a -> a) -> [[a]] -> (# [[a]] #)
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U>, Inline: [0],
     Unfolding: (\ @ a (w :: a -> a -> a) (ww :: [[a]]) ->
                 case ww of wild {
                   [] -> case Matrix.zipWithLines1 ret_ty (# [[a]] #) of {}
                   : x xs
                   -> letrec {
                        go1 :: [[a]] -> [a] {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds :: [[a]]) ->
                          case ds of wild1 {
                            [] -> x : y ys -> GHC.List.zipWith @ a @ a @ a w y (go1 ys) }
                      } in
                      case go1 xs of wild1 {
                        [] -> (# GHC.Types.[] @ [a] #)
                        : ipv ipv1
                        -> (# GHC.Types.: @ [a] wild1 (GHC.Types.[] @ [a]) #) } }) -}
02b27f11c61bc20edf880b673c1d3478
  $wzipWithM ::
    (a -> b -> c)
    -> [[a]] -> [[b]] -> MaybeResult.MaybeRes (Matrix.Matrix c)
  {- Arity: 3, Strictness: <L,C(C1(U))><S,1*U><S,1*U>, Inline: [0] -}
85be3ac288743dd1187a4ec813a19c6d
  type Axis = GHC.Types.Int
768b6bc11bdfdd20922a1ceee57fe31e
  type Height = GHC.Types.Int
02b27f11c61bc20edf880b673c1d3478
  data Matrix a = Matrix [[a]]
019a69829a71baef17c9c1f46235cb79
  type Width = GHC.Types.Int
0b22fa8ff01e5602a7198d36b5c3735e
  conhor ::
    Matrix.Matrix a
    -> Matrix.Matrix a -> MaybeResult.MaybeRes (Matrix.Matrix a)
  {- Arity: 2, Strictness: <S(S),1*U(U)><S(S),1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: Matrix.Matrix a) (w1 :: Matrix.Matrix a) ->
                 case w of ww { Matrix.Matrix ww1 ->
                 case w1 of ww2 { Matrix.Matrix ww3 ->
                 Matrix.$wconhor @ a ww1 ww3 } }) -}
e2be4fdcf0e416a0fe1a535de8368439
  conhor1 :: MaybeResult.MaybeRes (Matrix.Matrix a)
  {- Strictness: m2,
     Unfolding: (\ @ a ->
                 MaybeResult.Error @ (Matrix.Matrix a) Matrix.conhor2) -}
37668f291ac4d94f11b5ecfed8035364
  conhor2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "Matrixes must have same horizontal edge."#) -}
80380722d94316e4bb7d8dde93f4cbab
  conver ::
    Matrix.Matrix a
    -> Matrix.Matrix a -> MaybeResult.MaybeRes (Matrix.Matrix a)
  {- Arity: 2, Strictness: <S(S),1*U(U)><S(S),1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: Matrix.Matrix a) (w1 :: Matrix.Matrix a) ->
                 case w of ww { Matrix.Matrix ww1 ->
                 case w1 of ww2 { Matrix.Matrix ww3 ->
                 Matrix.$wconver @ a ww1 ww3 } }) -}
a5d89596a43ede08cb0f2afb5a42a42c
  conver1 :: MaybeResult.MaybeRes (Matrix.Matrix a)
  {- Strictness: m2,
     Unfolding: (\ @ a ->
                 MaybeResult.Error @ (Matrix.Matrix a) Matrix.conver2) -}
d3572ac69fe6da492c3f20dee69a3ab2
  conver2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "Matrixes must have same vertical edge."#) -}
9e8f973e77dbea187afc00490dada603
  conver3 :: MaybeResult.MaybeRes (Matrix.Matrix c)
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (\ @ c ->
                 MaybeResult.JustRes @ (Matrix.Matrix c) (Matrix.emptyM @ c)) -}
8e8f021e56fcda846d74ffaaf4689d08
  deleteColumns ::
    [GHC.Types.Int] -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U(U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: [GHC.Types.Int]) (w1 :: Matrix.Matrix a) ->
                 case w1 of ww { Matrix.Matrix ww1 ->
                 case Matrix.$wdeleteColumns @ a w ww1 of ww2 { Unit# ww3 ->
                 Matrix.Matrix @ a ww3 } }) -}
75b8ac3853129464e2c23d78522b9fa1
  emptyM :: Matrix.Matrix a
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (\ @ a -> Matrix.Matrix @ a (GHC.Types.[] @ [a])) -}
8f24f0b73bda98c0a579fc3b2e8179c9
  filterLinesHor ::
    (a -> GHC.Types.Bool) -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S(S),1*U(1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: a -> GHC.Types.Bool) (w1 :: Matrix.Matrix a) ->
                 case w1 of ww { Matrix.Matrix ww1 ->
                 case Matrix.$wfilterLinesHor @ a w ww1 of ww2 { Unit# ww3 ->
                 Matrix.Matrix @ a ww3 } }) -}
c95b37258957dc7cbceb0f99558bf73f
  filterLinesVer ::
    (a -> GHC.Types.Bool) -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><L,1*U(1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: a -> GHC.Types.Bool) (w1 :: Matrix.Matrix a) ->
                 case Matrix.$wfilterLinesVer @ a w w1 of ww { Unit# ww1 ->
                 Matrix.Matrix @ a ww1 }) -}
a0bf1ddfeb4c59b7ddb745a101cfc743
  findAMostQuadraticEdgeSize :: [a] -> (Matrix.Width, Matrix.Height)
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (xs :: [a]) ->
                 case Matrix.findEdgeSizes @ a xs of wild {
                   [] -> GHC.List.badHead @ (Matrix.Width, Matrix.Height)
                   : x ds1 -> x }) -}
df50d8a07a4927f68a6c4b3752bc3c11
  findEdgeSizes :: [a] -> [(Matrix.Width, Matrix.Height)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ @ a (xs :: [a]) ->
                 case GHC.List.$wlenAcc @ a xs 0# of ww2 { DEFAULT ->
                 let {
                   x :: GHC.Prim.Double#
                   = GHC.Prim.sqrtDouble# (GHC.Prim.int2Double# ww2)
                 } in
                 let {
                   n :: GHC.Prim.Int# = GHC.Prim.double2Int# x
                 } in
                 let {
                   $j :: GHC.Prim.Int# -> [(Matrix.Width, Matrix.Height)]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x1 :: GHC.Prim.Int#)[OneShot] ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.># x1 ww2) of wild {
                       GHC.Types.False
                       -> let {
                            lvl32 :: [GHC.Types.Int] = GHC.Enum.eftInt 1# ww2
                          } in
                          letrec {
                            go1 :: GHC.Prim.Int# -> [(Matrix.Width, Matrix.Height)]
                              {- Arity: 1, Strictness: <S,U> -}
                            = \ (x2 :: GHC.Prim.Int#) ->
                              let {
                                z :: [(Matrix.Width, Matrix.Height)]
                                = case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.==# x2 ww2) of wild1 {
                                    GHC.Types.False -> go1 (GHC.Prim.+# x2 1#)
                                    GHC.Types.True -> GHC.Types.[] @ (Matrix.Width, Matrix.Height) }
                              } in
                              let {
                                lvl33 :: GHC.Types.Int = GHC.Types.I# x2
                              } in
                              letrec {
                                go2 :: [GHC.Types.Int] -> [(Matrix.Width, Matrix.Height)]
                                  {- Arity: 1, Strictness: <S,1*U> -}
                                = \ (ds :: [GHC.Types.Int]) ->
                                  case ds of wild1 {
                                    [] -> z
                                    : y ys
                                    -> case y of wild2 { GHC.Types.I# y1 ->
                                       case GHC.Prim.tagToEnum#
                                              @ GHC.Types.Bool
                                              (GHC.Prim.==# (GHC.Prim.*# x2 y1) ww2) of wild3 {
                                         GHC.Types.False -> go2 ys
                                         GHC.Types.True
                                         -> GHC.Types.:
                                              @ (Matrix.Width, Matrix.Height)
                                              (lvl33, wild2)
                                              (go2 ys) } } }
                              } in
                              go2 lvl32
                          } in
                          go1 x1
                       GHC.Types.True -> GHC.Types.[] @ (Matrix.Width, Matrix.Height) }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<## x (GHC.Prim.int2Double# n)) of wild1 {
                   GHC.Types.False -> $j n
                   GHC.Types.True -> $j (GHC.Prim.-# n 1#) } }) -}
8d454988fc7b2f01dc97b6aa673f2fc5
  getAvgColumnsMatrix ::
    (GHC.Num.Num a, GHC.Real.Fractional a, GHC.Real.Real a) =>
    Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 4,
     Strictness: <L,A><L,U(U,C(C1(U)),A,C(U))><L,U(U,U,C(U))><S(S),1*U(1*U)>m,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   ($dNum :: GHC.Num.Num a)
                   ($dFractional :: GHC.Real.Fractional a)
                   ($dReal :: GHC.Real.Real a)
                   (eta :: Matrix.Matrix a) ->
                 Matrix.$fFunctorMatrix_$cfmap
                   @ (a, a)
                   @ a
                   (Data.Tuple.fst @ a @ a)
                   (Matrix.getAvgRangeAboutColumns
                      @ a
                      (GHC.Real.$p1Fractional @ a $dFractional)
                      $dFractional
                      $dReal
                      eta)) -}
181fda00b034d92e371284b8296cc14b
  getAvgRangeAboutColumns ::
    (GHC.Num.Num a, GHC.Real.Fractional a, GHC.Real.Real a) =>
    Matrix.Matrix a -> Matrix.Matrix (a, a)
  {- Arity: 4,
     Strictness: <L,A><L,U(U,C(C1(U)),A,C(U))><L,U(U,U,C(U))><S(S),1*U(1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (w :: GHC.Num.Num a)
                   (w1 :: GHC.Real.Fractional a)
                   (w2 :: GHC.Real.Real a)
                   (w3 :: Matrix.Matrix a) ->
                 case w3 of ww { Matrix.Matrix ww1 ->
                 Matrix.$wgetAvgRangeAboutColumns @ a w1 w2 ww1 }) -}
b12ddae7cf03cb45694e7f0bd0231946
  getColumn :: GHC.Types.Int -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*U)><S,1*U(1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a (n :: GHC.Types.Int) (ds :: Matrix.Matrix a) ->
                 case ds of wild { Matrix.Matrix xs ->
                 Matrix.Matrix
                   @ a
                   (GHC.Types.:
                      @ [a]
                      (Matrix.getColumn1 @ a n xs)
                      (GHC.Types.[] @ [a])) }) -}
b6938e81babb54fb0b384014b63a175b
  getColumn1 :: GHC.Types.Int -> [[a]] -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*U)><S,1*U> -}
ea91aece3077a9baf020667f93b5ed1d
  getElementByInd ::
    (Matrix.Width, Matrix.Height)
    -> Matrix.Matrix a -> MaybeResult.MaybeRes a
  {- Arity: 2, Strictness: <S(S(S)L),1*U(1*U(U),U(U))><S(S),1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: (Matrix.Width, Matrix.Height))
                   (w1 :: Matrix.Matrix a) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Matrix.Matrix ww6 ->
                 Matrix.$wgetElementByInd @ a ww4 ww2 ww6 } } }) -}
08d385a7f2fb7d97311e03dd17928740
  getHeight :: Matrix.Matrix a -> Matrix.Height
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (x :: Matrix.Matrix a) ->
                 case Matrix.getSize @ a x of wild { (,) ds1 y -> y }) -}
df5f582c61998237a2505950e3dfaf2b
  getRangeColumnsMatrix ::
    (GHC.Num.Num a, GHC.Real.Fractional a, GHC.Real.Real a) =>
    Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 4,
     Strictness: <L,A><L,U(U,C(C1(U)),A,C(U))><L,U(U,U,C(U))><S(S),1*U(1*U)>m,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   ($dNum :: GHC.Num.Num a)
                   ($dFractional :: GHC.Real.Fractional a)
                   ($dReal :: GHC.Real.Real a)
                   (eta :: Matrix.Matrix a) ->
                 Matrix.$fFunctorMatrix_$cfmap
                   @ (a, a)
                   @ a
                   (Data.Tuple.snd @ a @ a)
                   (Matrix.getAvgRangeAboutColumns
                      @ a
                      (GHC.Real.$p1Fractional @ a $dFractional)
                      $dFractional
                      $dReal
                      eta)) -}
28b7f4fe8b2b38ce8bedf0ba8a285b51
  getRow :: GHC.Types.Int -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(1*U)><S(S),1*U(1*U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Types.Int) (w1 :: Matrix.Matrix a) ->
                 case w1 of ww { Matrix.Matrix ww1 ->
                 case Matrix.$wtransposeM @ a ww1 of ww2 { Unit# ww3 ->
                 case Matrix.$wtransposeM
                        @ a
                        (GHC.Types.:
                           @ [a]
                           (Matrix.getColumn1 @ a w ww3)
                           (GHC.Types.[] @ [a])) of ww4 { Unit# ww5 ->
                 Matrix.Matrix @ a ww5 } } }) -}
8c5637de90b77f0e45af4e21dbe431f8
  getSize :: Matrix.Matrix a -> (Matrix.Width, Matrix.Height)
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Matrix.Matrix a) ->
                 case w of ww { Matrix.Matrix ww1 ->
                 case Matrix.$wgetSize @ a ww1 of ww2 { (#,#) ww3 ww4 ->
                 (ww3, ww4) } }) -}
e8504d8e213a316ed9585ce9b5e5a3b0
  getWidth :: Matrix.Matrix a -> Matrix.Width
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (x :: Matrix.Matrix a) ->
                 case Matrix.getSize @ a x of wild { (,) x1 ds1 -> x1 }) -}
bce21b3c2e583d5e38bfd1cd89d03cc6
  howManyElements :: Matrix.Matrix a -> GHC.Types.Int
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Matrix.Matrix a) ->
                 case w of ww { Matrix.Matrix ww1 ->
                 case Matrix.$whowManyElements @ a ww1 of ww2 { DEFAULT ->
                 GHC.Types.I# ww2 } }) -}
1e2b280d6c2f0e4a7d304e6bbe2937aa
  howManyElements1 :: GHC.Types.Int
  {- Strictness: x -}
7a3a5b36097c5b2edd88b172d4ca6b2e
  isEmpty :: Matrix.Matrix a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Matrix.Matrix a) ->
                 case ds of wild { Matrix.Matrix ds1 ->
                 case ds1 of wild1 {
                   [] -> GHC.Types.False
                   : ds2 ds3
                   -> case ds2 of wild2 {
                        []
                        -> case ds3 of wild3 {
                             [] -> GHC.Types.True : ipv ipv1 -> GHC.Types.False }
                        : ipv ipv1 -> GHC.Types.False } } }) -}
e70769732296ade3b00d76c72039a6ef
  normalize :: Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Matrix.Matrix a) ->
                 case w of ww { Matrix.Matrix ww1 ->
                 case Matrix.$wnormalize @ a ww1 of ww2 { Unit# ww3 ->
                 Matrix.Matrix @ a ww3 } }) -}
26f2b521a9a023672efabd52aa587391
  normalize1 :: [a] -> Matrix.Height
  {- Arity: 1, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (x :: [a]) ->
                 case Matrix.findEdgeSizes @ a x of wild {
                   [] -> case GHC.List.badHead ret_ty Matrix.Height of {}
                   : x1 ds1 -> case x1 of wild1 { (,) ds2 y -> y } }) -}
77ef51d43f915b3edc9ab5bcaedd3c2e
  normalize2 :: [a] -> Matrix.Width
  {- Arity: 1, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (x :: [a]) ->
                 case Matrix.findEdgeSizes @ a x of wild {
                   [] -> case GHC.List.badHead ret_ty Matrix.Width of {}
                   : x1 ds1 -> case x1 of wild1 { (,) x2 ds2 -> x2 } }) -}
94bd6be8286023cc1e53abc94f85800d
  packM :: [[a]] -> Matrix.Matrix a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m,
     Unfolding: InlineRule (0, True, True) Matrix.Matrix -}
95b8f0b7cb38d1ba3974e6ab68ec0b55
  scaleLines ::
    (GHC.Num.Num a, GHC.Real.Fractional a, GHC.Real.Real a) =>
    Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 4,
     Strictness: <L,A><L,U(U,C(C1(U)),A,C(U))><L,U(U,U,C(U))><S(S),1*U(1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (w :: GHC.Num.Num a)
                   (w1 :: GHC.Real.Fractional a)
                   (w2 :: GHC.Real.Real a)
                   (w3 :: Matrix.Matrix a) ->
                 case w3 of ww { Matrix.Matrix ww1 ->
                 Matrix.$wscaleLines @ a w1 w2 ww1 }) -}
e727303e3e49590f81208aae87bf7944
  toASquareMatrix :: [a] -> Matrix.Matrix a
  {- Arity: 1, Strictness: <S,U>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (xs :: [a]) ->
                 Matrix.toRectMatrix
                   @ a
                   (Matrix.normalize2 @ a xs)
                   (Matrix.normalize1 @ a xs)
                   xs) -}
409d0856f32860256402e91a2f4830cd
  toHeightMatrix :: Matrix.Height -> [a] -> Matrix.Matrix a
  {- Arity: 2, Strictness: <L,U(U)><S,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: Matrix.Height) (w1 :: [a]) ->
                 case Matrix.$wtoHeightMatrix @ a w w1 of ww { Unit# ww1 ->
                 Matrix.Matrix @ a ww1 }) -}
3e40a7dcc540e3a4afad4436a7d1b598
  toList :: Matrix.Matrix a -> [a]
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Matrix.Matrix a) ->
                 case w of ww { Matrix.Matrix ww1 -> Matrix.$wtoList @ a ww1 }) -}
743982ea87a80eb3a11caa63059dc13d
  toRectMatrix ::
    Matrix.Width -> Matrix.Height -> [a] -> Matrix.Matrix a
  {- Arity: 3, Strictness: <L,1*U(1*U)><L,U(U)><S,1*U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a (w :: Matrix.Width) (w1 :: Matrix.Height) (w2 :: [a]) ->
                 case Matrix.$wtoRectMatrix @ a w w1 w2 of ww { Unit# ww1 ->
                 Matrix.Matrix @ a ww1 }) -}
619ff15dc9747f65bd4076aad358b1bc
  transposeM :: Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Matrix.Matrix a) ->
                 case w of ww { Matrix.Matrix ww1 ->
                 case Matrix.$wtransposeM @ a ww1 of ww2 { Unit# ww3 ->
                 Matrix.Matrix @ a ww3 } }) -}
f7e378d9f1b7404f1d43c8c9e1376029
  unpackM :: Matrix.Matrix a -> [[a]]
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Matrix.Matrix a) ->
                 case ds of wild { Matrix.Matrix xs -> xs }) -}
069417c132878c25074b114220839105
  vector :: [a] -> Matrix.Axis -> Matrix.Matrix a
  {- Arity: 2, Strictness: <S,1*U><L,1*U(1*U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: [a]) (w1 :: Matrix.Axis) ->
                 case w of wild {
                   [] -> Matrix.Matrix @ a (GHC.Types.[] @ [a])
                   : ipv ipv1
                   -> case w1 of wild1 { GHC.Types.I# ds ->
                      case ds of ds1 {
                        DEFAULT -> case Matrix.vector1 ret_ty (Matrix.Matrix a) of {}
                        0#
                        -> Matrix.Matrix @ a (GHC.Types.: @ [a] wild (GHC.Types.[] @ [a]))
                        1#
                        -> Matrix.Matrix
                             @ a
                             (case Matrix.$wmakeListOfOneElementLists
                                     @ a
                                     wild of ww { (#,#) ww1 ww2 ->
                              GHC.Types.: @ [a] ww1 ww2 }) } } }) -}
71ea4e2bd2dff8e85d4c92ee2b42e586
  vector1 :: Matrix.Matrix a
  {- Strictness: x -}
fb1f10929f2c2990621cc21af06cf015
  zipWithLines :: (a -> a -> a) -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, Strictness: <L,C(C1(U))><S(S),1*U(1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: a -> a -> a) (w1 :: Matrix.Matrix a) ->
                 case w1 of ww { Matrix.Matrix ww1 ->
                 case Matrix.$wzipWithLines @ a w ww1 of ww2 { Unit# ww3 ->
                 Matrix.Matrix @ a ww3 } }) -}
ee7e5501297bce52412f30f3c1d5fdf5
  zipWithLines1 :: Matrix.Matrix a
  {- Strictness: x -}
fcfd47163a85880b28c61da2be0ec9d7
  zipWithM ::
    (a -> b -> c)
    -> Matrix.Matrix a
    -> Matrix.Matrix b
    -> MaybeResult.MaybeRes (Matrix.Matrix c)
  {- Arity: 3,
     Strictness: <L,C(C1(U))><S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   @ c
                   (w :: a -> b -> c)
                   (w1 :: Matrix.Matrix a)
                   (w2 :: Matrix.Matrix b) ->
                 case w1 of ww { Matrix.Matrix ww1 ->
                 case w2 of ww2 { Matrix.Matrix ww3 ->
                 Matrix.$wzipWithM @ a @ b @ c w ww1 ww3 } }) -}
instance [safe] GHC.Classes.Eq [Matrix.Matrix] = Matrix.$fEqMatrix
instance [safe] GHC.Base.Functor [Matrix.Matrix]
  = Matrix.$fFunctorMatrix
instance [safe] GHC.Num.Num [Matrix.Matrix] = Matrix.$fNumMatrix
instance [safe] GHC.Show.Show [Matrix.Matrix] = Matrix.$fShowMatrix
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

