
==================== FINAL INTERFACE ====================
2017-01-02 17:18:00.579676 UTC

interface Regression-0.1.0.0-BgfkxP9qOsG1ta2nZqj6mX:Matrix 8001
  interface hash: dec191439cc9a996ad28c68058d7df1e
  ABI hash: f36834f917daeb4aedd4abfc28876e61
  export-list hash: 9d0acc667c9877189a5e7c373de58a75
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: a4046e0fdab24403354cf30558c1ea1c
  sig of: Nothing
  used TH splices: False
  where
exports:
  Matrix.conhor
  Matrix.conver
  Matrix.deleteColumns
  Matrix.emptyM
  Matrix.filterLinesHor
  Matrix.filterLinesVer
  Matrix.findAMostQuadraticEdgeSize
  Matrix.findEdgeSizes
  Matrix.getColumn
  Matrix.getElementByInd
  Matrix.getSize
  Matrix.howManyElements
  Matrix.normalize
  Matrix.packM
  Matrix.scaleLines
  Matrix.toASquareMatrix
  Matrix.toHeightMatrix
  Matrix.toList
  Matrix.toRectMatrix
  Matrix.transposeM
  Matrix.unpackM
  Matrix.vector
  Matrix.zipWithLines
  Matrix.zipWithM
  Matrix.Matrix{Matrix.EmptyM Matrix.Matrix}
module dependencies:
package dependencies: base-4.9.0.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Either base-4.9.0.0:Data.Functor.Const
                         base-4.9.0.0:Data.Monoid base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:GHC.Generics base-4.9.0.0:GHC.IO.Exception
                         base-4.9.0.0:GHC.TypeLits
import  -/  base-4.9.0.0:Data.Foldable 8aeb682f6c74f97fcf0ace0d608a43ea
import  -/  base-4.9.0.0:Data.List 49b86831b79b49ce5d4d9416ecba61df
import  -/  base-4.9.0.0:Data.OldList 0058409f994fb13ae0616e3f1e5b4dae
import  -/  base-4.9.0.0:Data.Tuple acb0ed10307ed88df6c81b8589f4de16
import  -/  base-4.9.0.0:GHC.Base 8ed3be81c0707b322f975a84ae1bb816
import  -/  base-4.9.0.0:GHC.Err 3bba35a16538d33d424682ce66876cdd
import  -/  base-4.9.0.0:GHC.Float 469226b1bc53433e95d0167dec5d0312
import  -/  base-4.9.0.0:GHC.List 13d2451194c1c6e53b4f4f07947736dd
import  -/  base-4.9.0.0:GHC.Num 48f506a8f4ecf06285d0a0706594dcc0
import  -/  base-4.9.0.0:GHC.Real 08bf4acb5f2508f89d6fbcd57fe232e9
import  -/  base-4.9.0.0:GHC.Show 952347a6ab730bcb25c0854d8bc6ca51
import  -/  base-4.9.0.0:Prelude b9bddb97799837fe67a8d00939a5b6c3
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
a2b556be1159da4d11b738ee1acc9b79
  $fEqMatrix :: GHC.Classes.Eq a => GHC.Classes.Eq (Matrix.Matrix a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dEq :: GHC.Classes.Eq a).
                  @ (Matrix.Matrix a)
                  (Matrix.$fEqMatrix_$c== @ a $dEq)
                  (Matrix.$fEqMatrix_$c/= @ a $dEq) -}
b8e3d8f5f50b5f0dcaea3abebc867882
  $fEqMatrix1 :: [[a]]
  {- Strictness: x -}
a2b556be1159da4d11b738ee1acc9b79
  $fEqMatrix_$c/= ::
    GHC.Classes.Eq a =>
    Matrix.Matrix a -> Matrix.Matrix a -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (x :: Matrix.Matrix a)
                   (y :: Matrix.Matrix a) ->
                 GHC.Classes.not (Matrix.$fEqMatrix_$c== @ a $dEq x y)) -}
a2b556be1159da4d11b738ee1acc9b79
  $fEqMatrix_$c== ::
    GHC.Classes.Eq a =>
    Matrix.Matrix a -> Matrix.Matrix a -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,1*U(1*C(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (a1 :: Matrix.Matrix a)
                   (b :: Matrix.Matrix a) ->
                 case Matrix.zipWithM
                        @ a
                        @ a
                        @ GHC.Types.Bool
                        (GHC.Classes.== @ a $dEq)
                        a1
                        b of wild {
                   Matrix.EmptyM
                   -> case Matrix.$fEqMatrix1 ret_ty GHC.Types.Bool of {}
                   Matrix.Matrix xs
                   -> (Matrix.$fEqMatrix_go xs) `cast` (Data.Monoid.N:All[0]) }) -}
f0ae6e44e9003777f28df9bfa17af8db
  $fEqMatrix_go :: [[GHC.Types.Bool]] -> Data.Monoid.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
a2b556be1159da4d11b738ee1acc9b79
  $fFunctorMatrix :: GHC.Base.Functor Matrix.Matrix
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Matrix.Matrix
                  Matrix.$fFunctorMatrix_$cfmap
                  Matrix.$fFunctorMatrix_$c<$ -}
a2b556be1159da4d11b738ee1acc9b79
  $fFunctorMatrix_$c<$ :: a -> Matrix.Matrix b -> Matrix.Matrix a
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (eta :: a) (eta1 :: Matrix.Matrix b) ->
                 Matrix.$fFunctorMatrix_$cfmap @ b @ a (\ (ds :: b) -> eta) eta1) -}
a2b556be1159da4d11b738ee1acc9b79
  $fFunctorMatrix_$cfmap ::
    (a -> b) -> Matrix.Matrix a -> Matrix.Matrix b
  {- Arity: 2, Strictness: <L,C(U)><S,1*U> -}
a2b556be1159da4d11b738ee1acc9b79
  $fNumMatrix :: GHC.Num.Num a => GHC.Num.Num (Matrix.Matrix a)
  DFunId
  {- Arity: 1,
     Strictness: <L,U(C(C1(U)),A,C(C1(U)),C(U),C(U),C(U),C(U))>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dNum :: GHC.Num.Num a).
                  @ (Matrix.Matrix a)
                  (Matrix.$fNumMatrix_$c+ @ a $dNum)
                  (Matrix.$fNumMatrix_$c- @ a $dNum)
                  (Matrix.$fNumMatrix_$c* @ a $dNum)
                  (Matrix.$fNumMatrix_$cnegate @ a $dNum)
                  (Matrix.$fNumMatrix_$cabs @ a $dNum)
                  (Matrix.$fNumMatrix_$csignum @ a $dNum)
                  (Matrix.$fNumMatrix_$cfromInteger @ a $dNum) -}
a2b556be1159da4d11b738ee1acc9b79
  $fNumMatrix_$c* ::
    GHC.Num.Num a =>
    Matrix.Matrix a -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,C(C1(U)),A,A,A,C(U))><S,1*U><S,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dNum :: GHC.Num.Num a)
                   (a1 :: Matrix.Matrix a)
                   (b :: Matrix.Matrix a) ->
                 Matrix.transposeM
                   @ a
                   (Matrix.mulling @ a $dNum (Matrix.transposeM @ a a1) b)) -}
a2b556be1159da4d11b738ee1acc9b79
  $fNumMatrix_$c+ ::
    GHC.Num.Num a =>
    Matrix.Matrix a -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 3,
     Strictness: <L,1*U(1*C(C1(U)),A,A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dNum :: GHC.Num.Num a)
                   (eta :: Matrix.Matrix a)
                   (eta1 :: Matrix.Matrix a) ->
                 Matrix.zipWithM @ a @ a @ a (GHC.Num.+ @ a $dNum) eta eta1) -}
a2b556be1159da4d11b738ee1acc9b79
  $fNumMatrix_$c- ::
    GHC.Num.Num a =>
    Matrix.Matrix a -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,C(C1(U)),C(U),C(U),C(U),C(U))><L,U><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ a
                   ($dNum :: GHC.Num.Num a)
                   (x :: Matrix.Matrix a)
                   (y :: Matrix.Matrix a) ->
                 Matrix.$fNumMatrix_$c+
                   @ a
                   $dNum
                   x
                   (Matrix.$fNumMatrix_$cnegate @ a $dNum y)) -}
a2b556be1159da4d11b738ee1acc9b79
  $fNumMatrix_$cabs ::
    GHC.Num.Num a => Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, Strictness: <L,1*U(A,A,A,A,1*C(U),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) (eta :: Matrix.Matrix a) ->
                 Matrix.$fFunctorMatrix_$cfmap
                   @ a
                   @ a
                   (GHC.Num.abs @ a $dNum)
                   eta) -}
a2b556be1159da4d11b738ee1acc9b79
  $fNumMatrix_$cfromInteger ::
    GHC.Num.Num a => GHC.Integer.Type.Integer -> Matrix.Matrix a
  {- Arity: 2, Strictness: <L,1*U(A,A,A,A,A,A,1*C1(U))><L,U>,
     Unfolding: (\ @ a
                   ($dNum :: GHC.Num.Num a)
                   (x :: GHC.Integer.Type.Integer) ->
                 let {
                   xs :: a = GHC.Num.fromInteger @ a $dNum x
                 } in
                 let {
                   xs1 :: [a] = GHC.Types.: @ a xs (GHC.Types.[] @ a)
                 } in
                 Matrix.toRectMatrix
                   @ a
                   (case Matrix.findEdgeSizes @ a xs1 of wild {
                      [] -> case GHC.List.badHead ret_ty Matrix.Width of {}
                      : x1 ds1 -> case x1 of wild1 { (,) x2 ds2 -> x2 } })
                   (case Matrix.findEdgeSizes @ a xs1 of wild {
                      [] -> case GHC.List.badHead ret_ty Matrix.Height of {}
                      : x1 ds1 -> case x1 of wild1 { (,) ds2 y -> y } })
                   xs1) -}
a2b556be1159da4d11b738ee1acc9b79
  $fNumMatrix_$cnegate ::
    GHC.Num.Num a => Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, Strictness: <L,1*U(A,A,A,1*C(U),A,A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) (eta :: Matrix.Matrix a) ->
                 Matrix.$fFunctorMatrix_$cfmap
                   @ a
                   @ a
                   (GHC.Num.negate @ a $dNum)
                   eta) -}
a2b556be1159da4d11b738ee1acc9b79
  $fNumMatrix_$csignum ::
    GHC.Num.Num a => Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, Strictness: <L,1*U(A,A,A,A,A,1*C(U),A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) (eta :: Matrix.Matrix a) ->
                 Matrix.$fFunctorMatrix_$cfmap
                   @ a
                   @ a
                   (GHC.Num.signum @ a $dNum)
                   eta) -}
a2b556be1159da4d11b738ee1acc9b79
  $fShowMatrix :: GHC.Show.Show a => GHC.Show.Show (Matrix.Matrix a)
  DFunId
  {- Arity: 1, Strictness: <L,U(A,U,A)>m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dShow :: GHC.Show.Show a).
                  @ (Matrix.Matrix a)
                  (Matrix.$fShowMatrix_$cshowsPrec @ a $dShow)
                  (Matrix.$fShowMatrix_$cshow @ a $dShow)
                  (Matrix.$fShowMatrix_$cshowList @ a $dShow) -}
1d38f1d2ac9287b884886386c3029817
  $fShowMatrix1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# " "#) -}
e962fd0fdf806e560106508f2d56ad44
  $fShowMatrix2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "\n"#) -}
694212de63d5b57541a784c97f3efe4d
  $fShowMatrix3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Empty matrix"#) -}
a2b556be1159da4d11b738ee1acc9b79
  $fShowMatrix_$cshow ::
    GHC.Show.Show a => Matrix.Matrix a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(A,1*U,A)><S,1*U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ds :: Matrix.Matrix a) ->
                 case ds of wild {
                   Matrix.EmptyM -> Matrix.$fShowMatrix3
                   Matrix.Matrix ipv
                   -> case Matrix.transposeM @ a wild of wild1 {
                        Matrix.EmptyM
                        -> case Matrix.$fEqMatrix1 ret_ty GHC.Base.String of {}
                        Matrix.Matrix xs
                        -> let {
                             g :: a -> [GHC.Types.Char] = GHC.Show.show @ a $dShow
                           } in
                           letrec {
                             go1 :: [a] -> [GHC.Types.Char] {- Arity: 1, Strictness: <S,1*U> -}
                             = \ (ds1 :: [a]) ->
                               case ds1 of wild2 {
                                 [] -> Matrix.$fShowMatrix_z
                                 : y ys
                                 -> GHC.Base.++
                                      @ GHC.Types.Char
                                      (GHC.Base.++ @ GHC.Types.Char (g y) Matrix.$fShowMatrix1)
                                      (go1 ys) }
                           } in
                           letrec {
                             go2 :: [[a]] -> [GHC.Types.Char]
                               {- Arity: 1, Strictness: <S,1*U> -}
                             = \ (ds1 :: [[a]]) ->
                               case ds1 of wild2 {
                                 [] -> GHC.Types.[] @ GHC.Types.Char
                                 : y ys -> GHC.Base.++ @ GHC.Types.Char (go1 y) (go2 ys) }
                           } in
                           go2 xs } }) -}
a2b556be1159da4d11b738ee1acc9b79
  $fShowMatrix_$cshowList ::
    GHC.Show.Show a => [Matrix.Matrix a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(A,U,A)><S,1*U><L,U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [Matrix.Matrix a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Matrix.Matrix a)
                   (\ (x :: Matrix.Matrix a) (s1 :: GHC.Base.String)[OneShot] ->
                    GHC.Base.++
                      @ GHC.Types.Char
                      (Matrix.$fShowMatrix_$cshow @ a $dShow x)
                      s1)
                   ls
                   s) -}
a2b556be1159da4d11b738ee1acc9b79
  $fShowMatrix_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> Matrix.Matrix a -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <L,1*U(A,1*U,A)><L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ds :: GHC.Types.Int)
                   (x :: Matrix.Matrix a)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Matrix.$fShowMatrix_$cshow @ a $dShow x))
                   s) -}
658be5f7e0538ae3ab408ac70a4f8a7b
  $fShowMatrix_z :: [GHC.Types.Char]
  {- Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   Matrix.$fShowMatrix2
                   (GHC.Types.[] @ GHC.Types.Char)) -}
03e6821fd63fc6ff20ba6b766c45eee6
  $tc'EmptyM :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10998939451333070695##
                   13591662482535266634##
                   Matrix.$trModule
                   Matrix.$tc'EmptyM1) -}
9215a3acadfdde400c2fd6bcc10de73c
  $tc'EmptyM1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'EmptyM"#) -}
6fb38f5e009797391ffa17baadf474f0
  $tc'Matrix :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9519218874261716999##
                   14241207881608406365##
                   Matrix.$trModule
                   Matrix.$tc'Matrix1) -}
1a0fa0ef3920b5f1b72809424f4282eb
  $tc'Matrix1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Matrix"#) -}
2f15a8e14fd2afefe803bfa569cfd167
  $tcMatrix :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6879586085828880067##
                   6167075844438285825##
                   Matrix.$trModule
                   Matrix.$trModule1) -}
90ca189929dc2c55c0b3252a81416dc9
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Matrix.$trModule2
                   Matrix.$trModule1) -}
fc8262e8b372b6e16b1978650674318e
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Matrix"#) -}
2c8fa4d13072e5b49b37cb2650944517
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "Regression-0.1.0.0-BgfkxP9qOsG1ta2nZqj6mX"#) -}
9acc7899e2d16aff6661ad53e0622339
  $wfilterLinesVer ::
    (a -> GHC.Types.Bool) -> Matrix.Matrix a -> (# [[a]] #)
  {- Arity: 2, Strictness: <L,C(U)><L,1*U>, Inline: [0],
     Unfolding: (\ @ a
                   (w :: a -> GHC.Types.Bool)
                   (w1 :: Matrix.Matrix a) ->
                 (# case w1 of wild {
                      Matrix.EmptyM -> case Matrix.$fEqMatrix1 ret_ty [[a]] of {}
                      Matrix.Matrix xs
                      -> GHC.List.filter
                           @ [a]
                           (\ (eta :: [a]) ->
                            letrec {
                              go1 :: [a] -> Data.Monoid.All {- Arity: 1, Strictness: <S,1*U> -}
                              = \ (ds :: [a]) ->
                                case ds of wild1 {
                                  [] -> GHC.Types.True `cast` (Sym (Data.Monoid.N:All[0]))
                                  : y ys
                                  -> case w y of wild2 {
                                       GHC.Types.False
                                       -> GHC.Types.False `cast` (Sym (Data.Monoid.N:All[0]))
                                       GHC.Types.True -> go1 ys } }
                            } in
                            go1 eta)
                             `cast`
                           (<[a]>_R ->_R Data.Monoid.N:All[0])
                           xs } #)) -}
237748f5c31a98a23af3e979f3352d88
  $wgetElementByInd ::
    GHC.Prim.Int# -> GHC.Prim.Int# -> Matrix.Matrix a -> a
  {- Arity: 3, Strictness: <S,U><S,U><S,1*U>, Inline: [0],
     Unfolding: (\ @ a
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (w :: Matrix.Matrix a) ->
                 case w of wild {
                   Matrix.EmptyM -> Matrix.getElementByInd4 @ a
                   Matrix.Matrix xs
                   -> case GHC.List.$wlenAcc @ [a] xs 0# of ww2 { DEFAULT ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.># ww ww2) of wild1 {
                        GHC.Types.False
                        -> case xs of wild2 {
                             [] -> case GHC.List.badHead ret_ty a of {}
                             : x ds1
                             -> case GHC.List.$wlenAcc @ a x 0# of ww3 { DEFAULT ->
                                case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.># ww1 ww3) of wild3 {
                                  GHC.Types.False
                                  -> Matrix.getElementByInd3
                                       @ a
                                       ww1
                                       (Matrix.getElementByInd2 @ a ww wild2)
                                  GHC.Types.True -> Matrix.getElementByInd1 @ a wild2 ww1 ww } } }
                        GHC.Types.True -> Matrix.getElementByInd1 @ a xs ww1 ww } } }) -}
1bbb2c02fc9beaaec5e379d059714a2f
  $wgetSize :: Matrix.Matrix a -> (# Matrix.Width, Matrix.Height #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ @ a (w :: Matrix.Matrix a) ->
                 case w of wild {
                   Matrix.EmptyM
                   -> case Matrix.getSize1
                      ret_ty (# Matrix.Width, Matrix.Height #)
                      of {}
                   Matrix.Matrix ds
                   -> case ds of wild1 {
                        []
                        -> case Matrix.getSize1
                           ret_ty (# Matrix.Width, Matrix.Height #)
                           of {}
                        : x xs
                        -> (# case GHC.List.$wlenAcc @ [a] wild1 0# of ww2 { DEFAULT ->
                              GHC.Types.I# ww2 },
                              case GHC.List.$wlenAcc @ a x 0# of ww2 { DEFAULT ->
                              GHC.Types.I# ww2 } #) } }) -}
e6b0419edf29801dd543b51db2106c8a
  $whowManyElements :: Matrix.Matrix a -> GHC.Prim.Int#
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ @ a (w :: Matrix.Matrix a) ->
                 case w of wild {
                   Matrix.EmptyM
                   -> case Matrix.howManyElements1 ret_ty GHC.Prim.Int# of {}
                   Matrix.Matrix ds
                   -> case ds of wild1 {
                        [] -> case Matrix.howManyElements1 ret_ty GHC.Prim.Int# of {}
                        : x xs
                        -> case GHC.List.$wlenAcc @ a x 0# of ww2 { DEFAULT ->
                           case GHC.List.$wlenAcc @ [a] xs 0# of ww1 { DEFAULT ->
                           GHC.Prim.*# ww2 (GHC.Prim.+# ww1 1#) } } } }) -}
70c918763baa25c4875f17200f6cbfa8
  $wmakeListOfOneElementLists :: [a] -> (# [a], [[a]] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
470108ebd7c52d181143eeaf5b689551
  $wscaleLines ::
    (GHC.Real.Fractional a, GHC.Real.Real a) =>
    Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 3,
     Strictness: <L,U(U,C(C1(U)),A,C(U))><L,U(U,U,C(U))><S,1*U>,
     Inline: [0] -}
595778d6561afb6a26a627b70c56e4ff
  type Axis = GHC.Types.Int
c05c1c6f2d5dc0102a7fe5e405ed8c3f
  type Height = GHC.Types.Int
a2b556be1159da4d11b738ee1acc9b79
  data Matrix a = EmptyM | Matrix [[a]]
0a8afe67efab4975e80e9fdf10644a73
  type Width = GHC.Types.Int
9ca260b1bff224b69841ebba375d14f9
  concatHorizM ::
    Matrix.Matrix a -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
1486fbd5598e7b2cb9ec5c970cb2c0c8
  conhor ::
    Matrix.Matrix a
    -> Matrix.Matrix a -> GHC.Base.Maybe (Matrix.Matrix a)
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   (ds :: Matrix.Matrix a)
                   (ds1 :: Matrix.Matrix a) ->
                 case ds of wild {
                   Matrix.EmptyM -> Matrix.conhor1 @ a
                   Matrix.Matrix xs
                   -> case ds1 of wild1 {
                        Matrix.EmptyM -> Matrix.conhor1 @ a
                        Matrix.Matrix ys
                        -> case GHC.List.$wlenAcc @ [a] xs 0# of ww2 { DEFAULT ->
                           case GHC.List.$wlenAcc @ [a] ys 0# of ww1 { DEFAULT ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.==# ww2 ww1) of wild2 {
                             GHC.Types.False -> GHC.Base.Nothing @ (Matrix.Matrix a)
                             GHC.Types.True
                             -> GHC.Base.Just
                                  @ (Matrix.Matrix a)
                                  (Matrix.concatHorizM @ a wild wild1) } } } } }) -}
6ef80c89145fa401a12aeb34131d93a8
  conhor1 :: GHC.Base.Maybe (Matrix.Matrix a)
  {- Strictness: x -}
56cda7477c211ee9112b80bb956c154d
  conver ::
    Matrix.Matrix a
    -> Matrix.Matrix a -> GHC.Base.Maybe (Matrix.Matrix a)
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   (ds :: Matrix.Matrix a)
                   (ds1 :: Matrix.Matrix a) ->
                 case ds of wild {
                   Matrix.EmptyM -> Matrix.conver1 @ a
                   Matrix.Matrix ds2
                   -> case ds2 of wild1 {
                        [] -> Matrix.conver1 @ a
                        : x xs
                        -> case ds1 of wild2 {
                             Matrix.EmptyM -> Matrix.conver1 @ a
                             Matrix.Matrix ds3
                             -> case ds3 of wild3 {
                                  [] -> Matrix.conver1 @ a
                                  : y ys
                                  -> case GHC.List.$wlenAcc @ a x 0# of ww2 { DEFAULT ->
                                     case GHC.List.$wlenAcc @ a y 0# of ww1 { DEFAULT ->
                                     case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.==# ww2 ww1) of wild4 {
                                       GHC.Types.False -> GHC.Base.Nothing @ (Matrix.Matrix a)
                                       GHC.Types.True
                                       -> GHC.Base.Just
                                            @ (Matrix.Matrix a)
                                            (Matrix.Matrix
                                               @ a
                                               (GHC.Base.++ @ [a] wild1 wild3)) } } } } } } }) -}
9546809015487b99c53622ff7bd2c07a
  conver1 :: GHC.Base.Maybe (Matrix.Matrix a)
  {- Strictness: x -}
99fce7acc9d578792fef18164c0ee02c
  deleteColumns ::
    [GHC.Types.Int] -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
e8aa41e3258f5f9d8f69261c69e66f09
  emptyM :: Matrix.Matrix a
  {- HasNoCafRefs,
     Unfolding: InlineRule (0, True, True) Matrix.EmptyM -}
d01c26674886ab67636cd7ff81c9e156
  filterLinesHor ::
    (a -> GHC.Types.Bool) -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, Strictness: <L,C(U)><L,1*U>,
     Unfolding: (\ @ a
                   (f :: a -> GHC.Types.Bool)
                   (eta :: Matrix.Matrix a) ->
                 Matrix.transposeM
                   @ a
                   (Matrix.Matrix
                      @ a
                      (case Matrix.transposeM @ a eta of wild {
                         Matrix.EmptyM -> case Matrix.$fEqMatrix1 ret_ty [[a]] of {}
                         Matrix.Matrix xs
                         -> GHC.List.filter
                              @ [a]
                              (\ (eta1 :: [a]) ->
                               letrec {
                                 go1 :: [a] -> Data.Monoid.All {- Arity: 1, Strictness: <S,1*U> -}
                                 = \ (ds :: [a]) ->
                                   case ds of wild1 {
                                     [] -> GHC.Types.True `cast` (Sym (Data.Monoid.N:All[0]))
                                     : y ys
                                     -> case f y of wild2 {
                                          GHC.Types.False
                                          -> GHC.Types.False `cast` (Sym (Data.Monoid.N:All[0]))
                                          GHC.Types.True -> go1 ys } }
                               } in
                               go1 eta1)
                                `cast`
                              (<[a]>_R ->_R Data.Monoid.N:All[0])
                              xs }))) -}
d2ef440475a8b5db6256e8d216ab4f04
  filterLinesVer ::
    (a -> GHC.Types.Bool) -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, Strictness: <L,C(U)><L,1*U>m2, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: a -> GHC.Types.Bool) (w1 :: Matrix.Matrix a) ->
                 case Matrix.$wfilterLinesVer @ a w w1 of ww { Unit# ww1 ->
                 Matrix.Matrix @ a ww1 }) -}
4a293061be28d69c77ae5abca864f29c
  findAMostQuadraticEdgeSize :: [a] -> (Matrix.Width, Matrix.Height)
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (xs :: [a]) ->
                 case Matrix.findEdgeSizes @ a xs of wild {
                   [] -> GHC.List.badHead @ (Matrix.Width, Matrix.Height)
                   : x ds1 -> x }) -}
bd2159daf14027386a12e00612401585
  findEdgeSizes :: [a] -> [(Matrix.Width, Matrix.Height)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ @ a (xs :: [a]) ->
                 case GHC.List.$wlenAcc @ a xs 0# of ww2 { DEFAULT ->
                 let {
                   x :: GHC.Prim.Double#
                   = GHC.Prim.sqrtDouble# (GHC.Prim.int2Double# ww2)
                 } in
                 let {
                   n :: GHC.Prim.Int# = GHC.Prim.double2Int# x
                 } in
                 let {
                   $j :: GHC.Prim.Int# -> [(Matrix.Width, Matrix.Height)]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x1 :: GHC.Prim.Int#)[OneShot] ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.># x1 ww2) of wild {
                       GHC.Types.False
                       -> let {
                            lvl53 :: [GHC.Types.Int] = GHC.Enum.eftInt 1# ww2
                          } in
                          letrec {
                            go1 :: GHC.Prim.Int# -> [(Matrix.Width, Matrix.Height)]
                              {- Arity: 1, Strictness: <S,U> -}
                            = \ (x2 :: GHC.Prim.Int#) ->
                              let {
                                z :: [(Matrix.Width, Matrix.Height)]
                                = case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.==# x2 ww2) of wild1 {
                                    GHC.Types.False -> go1 (GHC.Prim.+# x2 1#)
                                    GHC.Types.True -> GHC.Types.[] @ (Matrix.Width, Matrix.Height) }
                              } in
                              let {
                                lvl54 :: GHC.Types.Int = GHC.Types.I# x2
                              } in
                              letrec {
                                go2 :: [GHC.Types.Int] -> [(Matrix.Width, Matrix.Height)]
                                  {- Arity: 1, Strictness: <S,1*U> -}
                                = \ (ds :: [GHC.Types.Int]) ->
                                  case ds of wild1 {
                                    [] -> z
                                    : y ys
                                    -> case y of wild2 { GHC.Types.I# y1 ->
                                       case GHC.Prim.tagToEnum#
                                              @ GHC.Types.Bool
                                              (GHC.Prim.==# (GHC.Prim.*# x2 y1) ww2) of wild3 {
                                         GHC.Types.False -> go2 ys
                                         GHC.Types.True
                                         -> GHC.Types.:
                                              @ (Matrix.Width, Matrix.Height)
                                              (lvl54, wild2)
                                              (go2 ys) } } }
                              } in
                              go2 lvl53
                          } in
                          go1 x1
                       GHC.Types.True -> GHC.Types.[] @ (Matrix.Width, Matrix.Height) }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<## x (GHC.Prim.int2Double# n)) of wild1 {
                   GHC.Types.False -> $j n
                   GHC.Types.True -> $j (GHC.Prim.-# n 1#) } }) -}
63bbc12313ee7e5385a73bd71365096f
  getColumn :: GHC.Types.Int -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, Strictness: <L,1*U(1*U)><S,1*U>m2,
     Unfolding: InlineRule (2, True, False)
                (\ @ a (n :: GHC.Types.Int) (ds :: Matrix.Matrix a) ->
                 case ds of wild {
                   Matrix.EmptyM -> Matrix.getColumn2 @ a
                   Matrix.Matrix xs
                   -> Matrix.Matrix
                        @ a
                        (GHC.Types.:
                           @ [a]
                           (Matrix.getColumn1 @ a n xs)
                           (GHC.Types.[] @ [a])) }) -}
5957772cfdb98f3ad2ccabcf152ab5ff
  getColumn1 :: GHC.Types.Int -> [[a]] -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*U)><S,1*U> -}
fceecde7e934c63f99b7e766804b9b03
  getColumn2 :: Matrix.Matrix a
  {- Strictness: x -}
1a12771adf0537c2e8e0d4c2f880aedf
  getElementByInd ::
    Matrix.Width -> Matrix.Height -> Matrix.Matrix a -> a
  {- Arity: 3, Strictness: <S(S),1*U(U)><S(S),U(U)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: Matrix.Width)
                   (w1 :: Matrix.Height)
                   (w2 :: Matrix.Matrix a) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { GHC.Types.I# ww3 ->
                 Matrix.$wgetElementByInd @ a ww1 ww3 w2 } }) -}
f76d6dd6ada1411737989dc084b9d5c7
  getElementByInd1 :: [[a]] -> GHC.Prim.Int# -> GHC.Prim.Int# -> a
  {- Arity: 3, Strictness: <L,U><L,U><L,U>x -}
aa78d488a54319cf3e65ea30f6fe7960
  getElementByInd2 :: GHC.Prim.Int# -> [[a]] -> [a]
  {- Arity: 2, Strictness: <S,U><S,1*U>, Inline: [0] -}
6ce8ea34d6cacd6062fd4bae0b836a6b
  getElementByInd3 :: GHC.Prim.Int# -> [a] -> a
  {- Arity: 2, Strictness: <S,U><S,1*U>, Inline: [0] -}
1cff58b8e19e3dfdbae6884eb13a55be
  getElementByInd4 :: a
  {- Strictness: x -}
797021e096a6adfdb5c815e5c33f3da7
  getSize :: Matrix.Matrix a -> (Matrix.Width, Matrix.Height)
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Matrix.Matrix a) ->
                 case Matrix.$wgetSize @ a w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
8ac13d28a262ef84891ea9560f966af3
  getSize1 :: (Matrix.Width, Matrix.Height)
  {- Strictness: x -}
05538de16d5f291fef043c9773e7d260
  howManyElements :: Matrix.Matrix a -> GHC.Types.Int
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Matrix.Matrix a) ->
                 case Matrix.$whowManyElements @ a w of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
2c30e51d3f5486a40bf4ded014d5d450
  howManyElements1 :: GHC.Types.Int
  {- Strictness: x -}
a2b556be1159da4d11b738ee1acc9b79
  mulling ::
    GHC.Num.Num a =>
    Matrix.Matrix a -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,C(C1(U)),A,A,A,C(U))><S,1*U><S,U> -}
724394389c645bfc14faf2271ce70ea4
  normalize :: Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a (x :: Matrix.Matrix a) ->
                 let {
                   xs :: [a] = Matrix.toList @ a x
                 } in
                 Matrix.toRectMatrix
                   @ a
                   (Matrix.normalize2 @ a xs)
                   (Matrix.normalize1 @ a xs)
                   xs) -}
72b2762362bb8f14e2e6589feeed881b
  normalize1 :: [a] -> Matrix.Height
  {- Arity: 1, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (x :: [a]) ->
                 case Matrix.findEdgeSizes @ a x of wild {
                   [] -> case GHC.List.badHead ret_ty Matrix.Height of {}
                   : x1 ds1 -> case x1 of wild1 { (,) ds2 y -> y } }) -}
396e47ac90f4258d7598f515fe4f28ee
  normalize2 :: [a] -> Matrix.Width
  {- Arity: 1, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (x :: [a]) ->
                 case Matrix.findEdgeSizes @ a x of wild {
                   [] -> case GHC.List.badHead ret_ty Matrix.Width of {}
                   : x1 ds1 -> case x1 of wild1 { (,) x2 ds2 -> x2 } }) -}
42f7445fd085d64029d463f5813bddca
  packM :: [[a]] -> Matrix.Matrix a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Unfolding: InlineRule (0, True, True) Matrix.Matrix -}
cc68aef62457ca6b0df1ee59f0c5a445
  scaleLines ::
    (GHC.Num.Num a, GHC.Real.Fractional a, GHC.Real.Real a) =>
    Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 4,
     Strictness: <L,A><L,U(U,C(C1(U)),A,C(U))><L,U(U,U,C(U))><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, True)
                (\ @ a
                   (w :: GHC.Num.Num a)
                   (w1 :: GHC.Real.Fractional a)
                   (w2 :: GHC.Real.Real a)
                   (w3 :: Matrix.Matrix a) ->
                 Matrix.$wscaleLines @ a w1 w2 w3) -}
cbcafc9faf0193a8dd0bf72e4d40f3d0
  toASquareMatrix :: [a] -> Matrix.Matrix a
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (xs :: [a]) ->
                 Matrix.toRectMatrix
                   @ a
                   (Matrix.normalize2 @ a xs)
                   (Matrix.normalize1 @ a xs)
                   xs) -}
a170d3f76753c9002ffda0959795b0aa
  toHeightMatrix :: Matrix.Height -> [a] -> Matrix.Matrix a
  {- Arity: 2, Strictness: <L,U(U)><S,U>,
     Unfolding: (\ @ a (height :: Matrix.Height) (xs :: [a]) ->
                 Matrix.toRectMatrix
                   @ a
                   (case GHC.List.$wlenAcc @ a xs 0# of ww2 { DEFAULT ->
                    case height of ww1 { GHC.Types.I# ww3 ->
                    case ww3 of wild {
                      DEFAULT
                      -> case GHC.Prim.quotInt# ww2 wild of ww4 { DEFAULT ->
                         GHC.Types.I# ww4 }
                      -1#
                      -> case ww2 of wild1 {
                           DEFAULT -> GHC.Types.I# (GHC.Prim.quotInt# wild1 -1#)
                           -9223372036854775808#
                           -> case GHC.Real.overflowError ret_ty Matrix.Width of {} }
                      0# -> case GHC.Real.divZeroError ret_ty Matrix.Width of {} } } })
                   height
                   xs) -}
585acb702b89f464751d0621eb298e0d
  toList :: Matrix.Matrix a -> [a]
  {- Arity: 1, Strictness: <S,1*U> -}
a2b556be1159da4d11b738ee1acc9b79
  toRectMatrix ::
    Matrix.Width -> Matrix.Height -> [a] -> Matrix.Matrix a
  {- Arity: 3, Strictness: <L,1*U(1*U)><L,U(U)><S,1*U> -}
a2b556be1159da4d11b738ee1acc9b79
  transposeM :: Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 1, Strictness: <S,1*U> -}
919d68e5b050ac0e565e0558b66c5008
  unpackM :: Matrix.Matrix a -> [[a]]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Matrix.Matrix a) ->
                 case ds of wild {
                   Matrix.EmptyM -> Matrix.$fEqMatrix1 @ a
                   Matrix.Matrix xs -> xs }) -}
a3ffda2b6133957f8b1e8e0979ff3ce6
  vector :: [a] -> Matrix.Axis -> Matrix.Matrix a
  {- Arity: 2, Strictness: <S,1*U><L,1*U(1*U)>,
     Unfolding: (\ @ a (ds :: [a]) (ds1 :: Matrix.Axis) ->
                 case ds of wild {
                   [] -> Matrix.EmptyM @ a
                   : ipv ipv1
                   -> case ds1 of wild1 { GHC.Types.I# ds2 ->
                      case ds2 of ds3 {
                        DEFAULT -> Matrix.vector1 @ a
                        0#
                        -> Matrix.Matrix @ a (GHC.Types.: @ [a] wild (GHC.Types.[] @ [a]))
                        1#
                        -> Matrix.Matrix
                             @ a
                             (case Matrix.$wmakeListOfOneElementLists
                                     @ a
                                     wild of ww { (#,#) ww1 ww2 ->
                              GHC.Types.: @ [a] ww1 ww2 }) } } }) -}
4a06b5800903f4d02950f10f3d977703
  vector1 :: Matrix.Matrix a
  {- Strictness: x -}
ef7e75cb8d2f44d8984459c69f33b92d
  zipWithLines :: (a -> a -> a) -> Matrix.Matrix a -> Matrix.Matrix a
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ a (f :: a -> a -> a) (ds :: Matrix.Matrix a) ->
                 case ds of wild {
                   Matrix.EmptyM -> Matrix.zipWithLines1 @ a
                   Matrix.Matrix ds1
                   -> case ds1 of wild1 {
                        [] -> Matrix.zipWithLines1 @ a
                        : x xs
                        -> letrec {
                             go1 :: [[a]] -> [a] {- Arity: 1, Strictness: <S,1*U> -}
                             = \ (ds2 :: [[a]]) ->
                               case ds2 of wild2 {
                                 [] -> x : y ys -> GHC.List.zipWith @ a @ a @ a f y (go1 ys) }
                           } in
                           case go1 xs of wild2 {
                             [] -> Matrix.EmptyM @ a
                             : ipv ipv1
                             -> Matrix.Matrix
                                  @ a
                                  (GHC.Types.: @ [a] wild2 (GHC.Types.[] @ [a])) } } }) -}
7e5f7f0d6d21c42c0acd21bc0f08b4af
  zipWithLines1 :: Matrix.Matrix a
  {- Strictness: x -}
a2b556be1159da4d11b738ee1acc9b79
  zipWithM ::
    (a -> b -> c)
    -> Matrix.Matrix a -> Matrix.Matrix b -> Matrix.Matrix c
  {- Arity: 3, Strictness: <L,C(C1(U))><S,1*U><S,1*U> -}
instance [safe] GHC.Classes.Eq [Matrix.Matrix] = Matrix.$fEqMatrix
instance [safe] GHC.Base.Functor [Matrix.Matrix]
  = Matrix.$fFunctorMatrix
instance [safe] GHC.Num.Num [Matrix.Matrix] = Matrix.$fNumMatrix
instance [safe] GHC.Show.Show [Matrix.Matrix] = Matrix.$fShowMatrix
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

